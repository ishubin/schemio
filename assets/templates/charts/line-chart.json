{"name": "Line chart", "description": "", "args": {"xMin": {"group": "Data", "type": "number", "value": 0, "name": "X min"}, "xMax": {"group": "Data", "type": "number", "value": 100, "name": "X max"}, "xStep": {"group": "Data", "type": "number", "value": 10, "name": "X step"}, "yMin": {"group": "Data", "type": "number", "value": 0, "name": "Y min"}, "yMax": {"group": "Data", "type": "number", "value": 100, "name": "Y max"}, "datasets": {"group": "Data", "name": "Datasets", "singular": "graph", "type": "array", "value": [{"id": "24tUTkZnn", "name": "Data 1", "values": "20, 40, 30, 50", "color": "#355E97FF", "strokeSize": 2, "strokePattern": "solid"}], "args": {"name": {"type": "string", "value": "Data ##IDX##", "name": "Name"}, "values": {"type": "string", "value": "20, 40, 25, 45", "name": "Values"}, "color": {"type": "color", "value": "#355E97FF", "name": "Color"}, "strokeSize": {"type": "number", "value": 2, "name": "Stroke size", "min": 0}, "strokePattern": {"type": "stroke-pattern", "value": "solid", "name": "Stroke Pattern"}}}, "background": {"group": "Style", "type": "color", "value": "#E8E8E9FF", "name": "Background"}, "strokeColor": {"group": "Style", "type": "color", "value": "#C7C7C7FF", "name": "Stroke color"}, "strokeSize": {"group": "Style", "type": "number", "value": 1, "name": "Stroke size"}, "gridColor": {"group": "Style", "type": "color", "value": "#BDBDBDFF", "name": "Grid color"}, "gridStrokeSize": {"group": "Style", "type": "number", "value": 1, "name": "Grid stroke size"}, "cornerRadius": {"group": "Style", "type": "number", "value": 5, "name": "Corner radius", "min": 0}, "lineType": {"group": "Style", "type": "choice", "value": "smooth", "options": ["linear", "smooth"], "name": "Line Type"}, "padding": {"group": "Style", "type": "number", "value": 20, "name": "Padding"}, "showPoints": {"group": "Points", "type": "boolean", "value": true, "name": "Show points"}, "pointType": {"group": "Points", "type": "choice", "options": ["simple", "hollow", "cut"], "value": "simple", "name": "Point type", "depends": {"showPoints": true}}, "pointSize": {"group": "Points", "type": "number", "value": 8, "min": 0, "softMax": 20, "name": "Point size"}, "titleFontSize": {"group": "Text", "type": "number", "value": 16, "name": "Title font size"}, "axisFontSize": {"group": "Text", "type": "number", "value": 14, "name": "Axis font size"}, "font": {"group": "Text", "type": "font", "value": "Arial", "name": "Font"}, "fontSize": {"group": "Text", "type": "number", "value": 14, "name": "Legend size"}, "fontColor": {"group": "Text", "type": "color", "value": "#333333FF", "name": "Label color"}, "hasLegend": {"group": "Legend", "type": "boolean", "value": true, "name": "Legend"}, "yTitle": {"group": "Axis", "type": "string", "value": "Y axis", "name": "Y Axis Name", "hidden": true}, "xTitle": {"group": "Axis", "type": "string", "value": "X axis", "name": "Y Axis Name", "hidden": true}, "yTitleShow": {"group": "Axis", "type": "boolean", "value": true, "name": "Show Y Axis Name"}, "xTitleShow": {"group": "Axis", "type": "boolean", "value": true, "name": "Show Y Axis Name"}}, "preview": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhodG1sPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmlld0JveD0iLTYgLTYgNDI0IDM3OCI+PGRlZnM+PHN0eWxlPgovKioqKioqKioqKioqKioqKioqIExhbmd1YWdlIE1hcmt1cCAqKioqKioqKioqKioqKiovCgouc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtc3Ryb25nLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1lbXBoYXNpc3tjb2xvcjojYThhOGEyfQouc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtYnVsbGV0LC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1xdW90ZSwuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtbGluaywuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtbnVtYmVyLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1yZWdleHAsLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLWxpdGVyYWx7Y29sb3I6IzY4OTZiYX0KLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLWNvZGUsLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLXNlbGVjdG9yLWNsYXNze2NvbG9yOiNhNmUyMmV9Ci5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1lbXBoYXNpc3tmb250LXN0eWxlOml0YWxpY30KLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLWtleXdvcmQsLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLXNlbGVjdG9yLXRhZywuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtc2VjdGlvbiwuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtYXR0cmlidXRlLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1uYW1lLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy12YXJpYWJsZXtjb2xvcjojY2I3ODMyfQouc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtcGFyYW1ze2NvbG9yOiNiZGM3OTF9Ci5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1zdHJpbmd7Y29sb3I6IzVhODg0MH0KLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLXN1YnN0LC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy10eXBlLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1idWlsdF9pbiwuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtYnVpbHRpbi1uYW1lLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1zeW1ib2wsLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLXNlbGVjdG9yLWlkLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1zZWxlY3Rvci1hdHRyLAouc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtc2VsZWN0b3ItcHNldWRvLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy10ZW1wbGF0ZS10YWcsLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLXRlbXBsYXRlLXZhcmlhYmxlLC5zeW50YXgtdGhlbWUtZGFyayAuaGxqcy1hZGRpdGlvbntjb2xvcjojZTBjNDZjfQouc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtY29tbWVudCwuc3ludGF4LXRoZW1lLWRhcmsgLmhsanMtZGVsZXRpb24sLnN5bnRheC10aGVtZS1kYXJrIC5obGpzLW1ldGF7Y29sb3I6IzdmN2Y3Zn0KCgouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWNvbW1lbnQsLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1xdW90ZSB7Y29sb3I6IzY1NWY2ZH0KLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy12YXJpYWJsZSwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXRlbXBsYXRlLXZhcmlhYmxlLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtYXR0cmlidXRlLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtdGFnLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtbmFtZSwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXJlZ2V4cCwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWxpbmssLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1uYW1lLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtbmFtZSwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXNlbGVjdG9yLWlkLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtc2VsZWN0b3ItY2xhc3N7Y29sb3I6I2JlNDY3OH0KLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1udW1iZXIsLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1tZXRhLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtYnVpbHRfaW4sLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1idWlsdGluLW5hbWUsLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1saXRlcmFsLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtdHlwZSwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXBhcmFtc3tjb2xvcjojYWE1NzNjfQouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXN0cmluZywuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXN5bWJvbCwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWJ1bGxldHtjb2xvcjojMmE5MjkyfQouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXRpdGxlLC5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtc2VjdGlvbntjb2xvcjojNTc2ZGRifQouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWtleXdvcmQsLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1zZWxlY3Rvci10YWd7Y29sb3I6Izk1NWFlN30KLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1kZWxldGlvbiwuc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWFkZGl0aW9ue2NvbG9yOiMxOTE3MWM7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MTAwJX0KLnN5bnRheC10aGVtZS1saWdodCAuaGxqcy1kZWxldGlvbntiYWNrZ3JvdW5kLWNvbG9yOiNiZTQ2Nzh9Ci5zeW50YXgtdGhlbWUtbGlnaHQgLmhsanMtYWRkaXRpb257YmFja2dyb3VuZC1jb2xvcjojMmE5MjkyfQouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLWVtcGhhc2lze2ZvbnQtc3R5bGU6aXRhbGljfQouc3ludGF4LXRoZW1lLWxpZ2h0IC5obGpzLXN0cm9uZ3tmb250LXdlaWdodDpib2xkfQoKCjwvc3R5bGU+PC9kZWZzPjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJIUklmeDM0UzY3IiBkYXRhLWl0ZW0taWQ9IkhSSWZ4MzRTNjciPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+IDxnIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGc+PGc+PGc+IDwvZz4gPHBhdGggZD0iTSA0MDIuMjI3MDMyMTAwMjIxMyAzNjYuMzY3Njg4MjMzNDI0NSAgTCAxMCAzNjYuMzY3Njg4MjMzNDI0NSBhIDEwIDEwIDAgMCAxIC0xMCAtMTAgIEwgMCAxMCAgYSAxMCAxMCAwIDAgMSAxMCAtMTAgICBMIDQwMi4yMjcwMzIxMDAyMjEzIDAgICBhIDEwIDEwIDAgMCAxIDEwIDEwICBMIDQxMi4yMjcwMzIxMDAyMjEzIDM1Ni4zNjc2ODgyMzM0MjQ1ICAgYSAxMCAxMCAwIDAgMSAtMTAgMTAgWiIgc3Ryb2tlLXdpZHRoPSIzcHgiIHN0cm9rZT0iI0M3QzdDN0ZGIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9IiNENEQ3RDlGRiIvPjwvZz48L2c+PC9nPiAgPGcvPjwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLUhSSWZ4MzRTNjciLz4gICAgICAgICA8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwLDEwKSI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj48ZyBtb2RlPSJlZGl0IiBzdHlsZT0ib3BhY2l0eTogMTsiPjxnPiA8L2c+IDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIzOTIuMjI3MDMyMTAwMjIxMyIgaGVpZ2h0PSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9IiNGQUZBRkFGRiIvPiA8bGluZSB4MT0iMzkuMjIyNzAzMjEwMDIyMTMiIHkxPSIwIiB4Mj0iMzkuMjIyNzAzMjEwMDIyMTMiIHkyPSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNzguNDQ1NDA2NDIwMDQ0MjYiIHkxPSIwIiB4Mj0iNzguNDQ1NDA2NDIwMDQ0MjYiIHkyPSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTE3LjY2ODEwOTYzMDA2NjQiIHkxPSIwIiB4Mj0iMTE3LjY2ODEwOTYzMDA2NjQiIHkyPSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTU2Ljg5MDgxMjg0MDA4ODUzIiB5MT0iMCIgeDI9IjE1Ni44OTA4MTI4NDAwODg1MyIgeTI9IjI5Ni4wMTMwMDA3MzM0MjQ0NiIgc3Ryb2tlPSIjRENEQkRCRkYiIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIxOTYuMTEzNTE2MDUwMTEwNjYiIHkxPSIwIiB4Mj0iMTk2LjExMzUxNjA1MDExMDY2IiB5Mj0iMjk2LjAxMzAwMDczMzQyNDQ2IiBzdHJva2U9IiNEQ0RCREJGRiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjIzNS4zMzYyMTkyNjAxMzI4IiB5MT0iMCIgeDI9IjIzNS4zMzYyMTkyNjAxMzI4IiB5Mj0iMjk2LjAxMzAwMDczMzQyNDQ2IiBzdHJva2U9IiNEQ0RCREJGRiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjI3NC41NTg5MjI0NzAxNTQ5IiB5MT0iMCIgeDI9IjI3NC41NTg5MjI0NzAxNTQ5IiB5Mj0iMjk2LjAxMzAwMDczMzQyNDQ2IiBzdHJva2U9IiNEQ0RCREJGRiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjMxMy43ODE2MjU2ODAxNzcwNiIgeTE9IjAiIHgyPSIzMTMuNzgxNjI1NjgwMTc3MDYiIHkyPSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMzUzLjAwNDMyODg5MDE5OTIiIHkxPSIwIiB4Mj0iMzUzLjAwNDMyODg5MDE5OTIiIHkyPSIyOTYuMDEzMDAwNzMzNDI0NDYiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz4gPGxpbmUgeDE9IjAiIHkxPSIyOS42MDEzMDAwNzMzNDI0NDciIHgyPSIzOTIuMjI3MDMyMTAwMjIxMyIgeTI9IjI5LjYwMTMwMDA3MzM0MjQ0NyIgc3Ryb2tlPSIjRENEQkRCRkYiIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIwIiB5MT0iNTkuMjAyNjAwMTQ2Njg0ODk0IiB4Mj0iMzkyLjIyNzAzMjEwMDIyMTMiIHkyPSI1OS4yMDI2MDAxNDY2ODQ4OTQiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMCIgeTE9Ijg4LjgwMzkwMDIyMDAyNzM0IiB4Mj0iMzkyLjIyNzAzMjEwMDIyMTMiIHkyPSI4OC44MDM5MDAyMjAwMjczNCIgc3Ryb2tlPSIjRENEQkRCRkYiIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIwIiB5MT0iMTE4LjQwNTIwMDI5MzM2OTc5IiB4Mj0iMzkyLjIyNzAzMjEwMDIyMTMiIHkyPSIxMTguNDA1MjAwMjkzMzY5NzkiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMCIgeTE9IjE0OC4wMDY1MDAzNjY3MTIyMyIgeDI9IjM5Mi4yMjcwMzIxMDAyMjEzIiB5Mj0iMTQ4LjAwNjUwMDM2NjcxMjIzIiBzdHJva2U9IiNEQ0RCREJGRiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjAiIHkxPSIxNzcuNjA3ODAwNDQwMDU0NyIgeDI9IjM5Mi4yMjcwMzIxMDAyMjEzIiB5Mj0iMTc3LjYwNzgwMDQ0MDA1NDciIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMCIgeTE9IjIwNy4yMDkxMDA1MTMzOTcxMiIgeDI9IjM5Mi4yMjcwMzIxMDAyMjEzIiB5Mj0iMjA3LjIwOTEwMDUxMzM5NzEyIiBzdHJva2U9IiNEQ0RCREJGRiIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjAiIHkxPSIyMzYuODEwNDAwNTg2NzM5NTgiIHgyPSIzOTIuMjI3MDMyMTAwMjIxMyIgeTI9IjIzNi44MTA0MDA1ODY3Mzk1OCIgc3Ryb2tlPSIjRENEQkRCRkYiIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIwIiB5MT0iMjY2LjQxMTcwMDY2MDA4MjAzIiB4Mj0iMzkyLjIyNzAzMjEwMDIyMTMiIHkyPSIyNjYuNDExNzAwNjYwMDgyMDMiIHN0cm9rZT0iI0RDREJEQkZGIiBzdHJva2Utd2lkdGg9IjIiLz48L2c+ICAgPGcvPjwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLXp5ejNkbk11TXMiLz4gICAgICAgICA8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAsMCkiPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+PGcgbW9kZT0iZWRpdCIgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz4gPC9nPiA8cGF0aCBkPSJNIDAgMjM2LjgxIEMgMzkuMjIgMjM2LjgxIDM5LjIzIDE3Ny42MSA3OC40NSAxNzcuNjEgQyAxMTcuNjcgMTc3LjYxIDExNy42NyAyMDcuMjEgMTU2Ljg5IDIwNy4yMSBDIDE5Ni4xMSAyMDcuMjEgMTk2LjEyIDE0OC4wMSAyMzUuMzQgMTQ4LjAxIEMgMjc0LjU2IDE0OC4wMSAyNzQuNTYgNTkuMiAzMTMuNzggNTkuMiBDIDM1MyA1OS4yIDM1My4wMSAyOS42IDM5Mi4yMyAyOS42ICAiIHN0cm9rZS13aWR0aD0iOHB4IiBzdHJva2U9IiMzNTVFOTdGRiIgc3Ryb2tlLWRhc2hhcnJheT0iIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiLz48L2c+ICAgPGcvPjwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLVRvUUNqRFB1eFYiLz4gICAgICAgICAgPC9nPjwvZz48L2c+IDwvZz48L2c+PGcgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMCwzMTYuMDEzMDAwNzMzNDI0NDYpIj4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPiA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiPjxnPjxnPjxnPiA8L2c+IDxwYXRoIGQ9Ik0gMzkyLjIyNzAzMjEwMDIyMTMgNTAuMzU0Njg3NTAwMDAwMDA0ICBMIDAgNTAuMzU0Njg3NTAwMDAwMDA0IGEgMCAwIDAgMCAxIDAgMCAgTCAwIDAgIGEgMCAwIDAgMCAxIDAgMCAgIEwgMzkyLjIyNzAzMjEwMDIyMTMgMCAgIGEgMCAwIDAgMCAxIDAgMCAgTCAzOTIuMjI3MDMyMTAwMjIxMyA1MC4zNTQ2ODc1MDAwMDAwMDQgICBhIDAgMCAwIDAgMSAwIDAgWiIgc3Ryb2tlLXdpZHRoPSIwcHgiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiLz48L2c+PC9nPjwvZz4gIDxnLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1hZVRzcEYwTXQiLz4gICAgICAgICA8Zz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDAsOSkiPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+IDxnIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGc+PGc+PGc+IDwvZz4gPHBhdGggZD0iTSAxMi41IDUgIEwgMi41IDUgYSAyLjUgMi41IDAgMCAxIC0yLjUgLTIuNSAgTCAwIDIuNSAgYSAyLjUgMi41IDAgMCAxIDIuNSAtMi41ICAgTCAxMi41IDAgICBhIDIuNSAyLjUgMCAwIDEgMi41IDIuNSAgTCAxNSAyLjUgICBhIDIuNSAyLjUgMCAwIDEgLTIuNSAyLjUgWiIgc3Ryb2tlLXdpZHRoPSIwcHgiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9IiMzNTVFOTdGRiIvPjwvZz48L2c+PC9nPiAgPGcvPjwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLTI2U1FtbWdTemgiLz4gICAgICAgICAgPC9nPjwvZz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDIwLDApIj4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPiA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz4gIDxnPjxnIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGZvcmVpZ25PYmplY3QgaWQ9Iml0ZW0tdGV4dC1zbG90LUlTdEYxQlh6RGQtYm9keSIgeD0iMCIgeT0iMCIgd2lkdGg9IjY0LjgxODM1OTM3NSIgaGVpZ2h0PSIzNS4zNTQ2ODc1MDAwMDAwMDQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJpdGVtLXRleHQtY29udGFpbmVyIiBzdHlsZT0iY29sb3I6IHJnYig1MSwgNTEsIDUxKTsgZm9udC1zaXplOiAyMnB4OyBmb250LWZhbWlseTogQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjsgcGFkZGluZzogMHB4OyB0ZXh0LWFsaWduOiBsZWZ0OyB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBkaXNwbGF5OiB0YWJsZS1jZWxsOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBsaW5lLWhlaWdodDogMTsgd2lkdGg6IDY0LjgxODRweDsgaGVpZ2h0OiAzNS4zNTQ3cHg7Ij48ZGl2IGNsYXNzPSJpdGVtLXRleHQtZWxlbWVudCIgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsiPkRhdGEgMTwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLUlTdEYxQlh6RGQiLz4gICAgICAgICAgPC9nPjwvZz48L2c+IDwvZz48L2c+PC9nPiA8L2c+PC9nPjwvc3ZnPg==", "defaultArea": {"x": 0, "y": 0, "w": 120, "h": 60}, "import": ["./src/base-chart.sch", "./src/line-chart.sch"], "handlers": {"text": "onTextUpdate(itemId, item, text)", "delete": "onDeleteItem(itemId, item)"}, "$-def:changeDataPointInitScript": {"$-str": "${baseScriptForFunctions}\n\nlocal pathItem = findChildItemsByTag('dataset-path').find((item) => { item.getName() == name })\nif (!pathItem || pathItem.getShape() != 'path') {\n  stop()\n  return\n}\n\nlocal values = data.split(',').map(parseInt)\nif (pathItem.totalPaths() == 0) {\n  pathItem.addPath()\n}\nlocal numPoints = pathItem.totalPathPoints(0)\nif (numPoints < values.size) {\n  local lastPointIdx = numPoints - 1\n  local lastPointY = pathItem.getPathPointPos(0, lastPointIdx).y\n\n  for (local i = numPoints; i < values.size; i++) {\n    if (lineType == 'smooth') {\n      pathItem.addBezierPoint(0, lastPointIdx * dx, lastPointY, 0, 0, 0, 0)\n    } else {\n      pathItem.addPoint(0, lastPointIdx * dx, lastPointY)\n    }\n  }\n}\n\nlocal srcPoints = pathItem.getPathPoints(0)\nlocal dstPoints = List()\nvalues.forEach((value, idx) => {\n  dstPoints.add(Point(idx * dx, (yMax - value) * plotHeight / dy))\n})\n\nlocal lastDstPoint = dstPoints.get(dstPoints.size - 1)\nfor (local i = values.size; i < numPoints; i++) {\n  dstPoints.add(lastDstPoint)\n}\n\n// smoothening the points\nsmoothenPoints(dstPoints)\n"}, "$-def:changeDataPointLoopScript": "changePointsInAnimation(pathItem, srcPoints, dstPoints, t)\n", "$-def:changeDataPointEndScript": "if (numPoints > values.size) {\n  for (local i = numPoints - 1; i >= values.size; i--) {\n    log('removing point', i)\n    pathItem.removePathPoint(0, i)\n  }\n}\n", "$-def:addDatasetInitScript": {"$-str": "${baseScriptForFunctions}\n\nlocal pathItem = buildItem('path', name)\npathItem.mount(plot)\npathItem.setPos(0, 0)\npathItem.setWidth(plot.getWidth())\npathItem.setHeight(plot.getHeight())\npathItem.setStrokeColor(color)\npathItem.setStrokeSize(strokeSize)\npathItem.setStrokePattern(strokePattern)\npathItem.addPath()\npathItem.tag('dataset-path')\n\nlocal values = data.split(',').map(parseInt)\n\nlocal valueY = yMax * plotHeight / dy\nfor (local i = 0; i < values.size; i++) {\n  if (lineType == 'smooth') {\n    pathItem.addBezierPoint(0, i * dx, valueY, 0, 0, 0, 0)\n  } else {\n    pathItem.addPoint(0, i * dx, valueY)\n  }\n}\n\nlocal srcPoints = List()\nlocal dstPoints = List()\nvalues.forEach((value, idx) => {\n  srcPoints.add(Point(idx * dx, valueY))\n  dstPoints.add(Point(idx * dx, (yMax - value) * plotHeight / dy))\n})\n\n// smoothening the points\nsmoothenPoints(dstPoints)\n"}, "$-def:addDatasetLoopScript": "changePointsInAnimation(pathItem, srcPoints, dstPoints, t)\npathItem.setOpacity(100 * t)\n", "$-def:removeDatasetInitScript": {"$-str": "${baseScriptForFunctions}\n\nlocal pathItem = findChildItemsByTag('dataset-path').find((item) => {item.getName() == name})\nif (!pathItem || pathItem.getShape() != 'path') {\n  stop()\n  return\n}\n\nlocal srcPoints = pathItem.getPathPoints(0)\nlocal dstPoints = List()\nsrcPoints.forEach((p, idx) => {\n  dstPoints.add(Point(idx * dx, 0))\n})\n"}, "$-def:removeDatasetLoopScript": {"$-str": "changePointsInAnimation(pathItem, srcPoints, dstPoints, t)\npathItem.setOpacity(100 * (1 - t))\n"}, "$-def:removeDatasetEndScript": {"$-str": "pathItem.remove()\n"}, "editor": {"panels": [{"id": "theme", "type": "item-menu", "click": "selectTheme(panelItem.id)", "name": "Theme", "slotSize": {"width": 100, "height": 100}, "items": [{"id": "light", "name": "Phone", "shape": "image", "area": {"x": 0, "y": 5, "w": 90, "h": 80}, "shapeProps": {"image": "/assets/templates/charts/images/line-chart-light.svg", "fill": {"type": "none"}, "strokeSize": 0}}, {"id": "dark", "name": "Phone", "shape": "image", "area": {"x": 0, "y": 5, "w": 90, "h": 80}, "shapeProps": {"image": "/assets/templates/charts/images/line-chart-dark.svg", "fill": {"type": "none"}, "strokeSize": 0}}]}]}, "item": {"id": "root", "name": "Line chart", "shape": "rect", "shapeProps": {"fill": {"type": "solid", "color": {"$-expr": "background"}}, "strokeColor": {"$-expr": "strokeColor"}, "strokeSize": {"$-expr": "strokeSize"}, "cornerRadius": {"$-expr": "cornerRadius"}}, "locked": false, "area": {"x": 0, "y": 0, "w": {"$-expr": "width"}, "h": {"$-expr": "height"}}, "functions": [{"id": "func1", "name": "Change data points", "args": [{"id": "arg-index", "name": "name", "value": "Data 1", "type": "string", "description": "The name of a dataset"}, {"id": "arg-data", "name": "data", "value": "1, 2, 4, 5", "type": "string", "description": "New data point values (comma separated)"}], "props": {"initScript": {"$-ref": "changeDataPointInitScript"}, "script": {"$-ref": "changeDataPointLoopScript"}, "endScript": {"$-ref": "changeDataPointEndScript"}, "animated": true, "animationType": "animation", "animationDuration": 0.5, "transition": "ease-out", "inBackground": true}}, {"id": "func2", "name": "Add dataset", "args": [{"id": "arg-name", "name": "name", "value": "New data", "type": "string", "description": "The name of a dataset"}, {"id": "arg-data", "name": "data", "value": "1, 2, 4, 5", "type": "string", "description": "New dataset values (comma separated)"}, {"id": "arg-color", "name": "color", "value": "#355E97FF", "type": "color"}, {"id": "arg-stroke-size", "name": "strokeSize", "value": 2, "type": "number"}, {"id": "arg-stroke-pattern", "name": "strokePattern", "value": "solid", "type": "stroke-pattern"}], "props": {"initScript": {"$-ref": "addDatasetInitScript"}, "script": {"$-ref": "addDatasetLoopScript"}, "endScript": "", "animated": true, "animationType": "animation", "animationDuration": 0.5, "transition": "ease-out", "inBackground": true}}, {"id": "func-delete-dataset", "name": "Delete dataset", "args": [{"id": "arg-name", "name": "name", "value": "Data 1", "type": "string", "description": "The name of a dataset that should be removed from the plot"}], "props": {"initScript": {"$-ref": "removeDatasetInitScript"}, "script": {"$-ref": "removeDatasetLoopScript"}, "endScript": {"$-ref": "removeDatasetEndScript"}, "animated": true, "animationType": "animation", "animationDuration": 0.5, "transition": "ease-out", "inBackground": true}}], "childItems": [{"id": "grid", "shape": "path", "name": "grid", "clip": false, "tags": ["chart-plot"], "area": {"x": {"$-expr": "plotOffset"}, "y": {"$-expr": "padding"}, "w": {"$-expr": "max(1, plotWidth)"}, "h": {"$-expr": "max(1, plotHeight)"}}, "shapeProps": {"strokeColor": {"$-expr": "gridColor"}, "strokeSize": {"$-expr": "gridStrokeSize"}, "paths": {"$-expr": "gridPaths"}}, "childItems": [{"$-foreach": {"source": "parsedDatasets", "it": "dataset"}, "id": {"$-str": "dataset-${dataset.args.id}"}, "name": {"$-expr": "dataset.args.name"}, "area": {"x": 0, "y": 0, "w": {"$-expr": "max(1, plotWidth)"}, "h": {"$-expr": "max(1, plotHeight)"}}, "shape": "path", "tags": ["dataset-path"], "shapeProps": {"smoothing": {"$-expr": "lineType"}, "strokeColor": {"$-expr": "dataset.args.color"}, "strokeSize": {"$-expr": "dataset.args.strokeSize"}, "strokePattern": {"$-expr": "dataset.args.strokePattern"}, "paths": [{"id": "dataset-path", "closed": false, "pos": "relative", "points": [{"$-foreach": {"source": "dataset.points", "it": "point", "index": "pointIdx"}, "$-extend": {"$-expr": "toJSON(point)"}, "id": {"$-expr": "pointIdx"}}]}]}, "childItems": [{"$-foreach": {"source": "dataset.points", "it": "point", "index": "pointIdx"}, "$-if": "showPoints || pointSize > 0", "id": {"$-str": "datapoint-${dataset.args.id}-${pointIdx}"}, "name": {"$-str": "Point ${pointIdx}"}, "shape": "ellipse", "area": {"x": {"$-expr": "point.x * plotWidth / 100 - pointSize/2"}, "y": {"$-expr": "point.y * plotHeight / 100 - pointSize/2"}, "w": {"$-expr": "pointSize"}, "h": {"$-expr": "pointSize"}}, "shapeProps": {"strokeSize": {"$-expr": "if (pointType == \"hollow\" || pointType == \"cut\") { 2 } else { 0 }"}, "fill": {"type": "solid", "color": {"$-expr": "if (pointType == \"hollow\") { background } else { dataset.args.color }"}}, "strokeColor": {"$-expr": "if (pointType == \"cut\") { background } else { dataset.args.color }"}}}]}]}, {"$-foreach": {"source": "yAxis.labels", "it": "label", "index": "labelIdx"}, "id": {"$-str": "y-axis-label-${labelIdx}"}, "name": {"$-str": "Y axis label ${label.text}"}, "shape": "none", "args": {"templateForceText": true}, "area": {"x": {"$-expr": "label.x"}, "y": {"$-expr": "label.y"}, "w": {"$-expr": "label.w"}, "h": {"$-expr": "label.h"}}, "textSlots": {"body": {"text": {"$-expr": "label.text"}, "color": {"$-expr": "fontColor"}, "font": {"$-expr": "font"}, "fontSize": {"$-expr": "fontSize"}, "halign": "right", "valign": "middle", "paddingRight": 5}}}, {"$-foreach": {"source": "xAxis.labels", "it": "label", "index": "labelIdx"}, "id": {"$-str": "x-axis-label-${labelIdx}"}, "name": {"$-str": "X axis label ${label.text}"}, "shape": "none", "args": {"templateForceText": true}, "area": {"x": {"$-expr": "label.x"}, "y": {"$-expr": "label.y"}, "w": {"$-expr": "label.w"}, "h": {"$-expr": "label.h"}}, "textSlots": {"body": {"text": {"$-expr": "label.text"}, "color": {"$-expr": "fontColor"}, "font": {"$-expr": "font"}, "fontSize": {"$-expr": "fontSize"}, "halign": "right", "valign": "middle", "paddingRight": 5}}}, {"id": "axis-title-y", "$-if": "yTitleShow", "shape": "none", "name": "Axis Y Title", "area": {"x": {"$-expr": "padding * 1.5 - plotHeight / 2"}, "y": {"$-expr": "(plotHeight - axisNameFontMaxHeight) / 2 + padding"}, "w": {"$-expr": "plotHeight"}, "h": {"$-expr": "axisNameFontMaxHeight"}, "r": -90}, "args": {"templateForceText": true}, "textSlots": {"body": {"text": {"$-expr": "yTitle"}, "valign": "bottom", "halign": "center", "color": {"$-expr": "fontColor"}, "font": {"$-expr": "font"}, "fontSize": {"$-expr": "titleFontSize"}}}}, {"id": "axis-title-x", "$-if": "xTitleShow", "shape": "none", "name": "Axis X Title", "area": {"x": {"$-expr": "plotOffset"}, "y": {"$-expr": "padding + plotHeight + xLabelsFullHeight"}, "w": {"$-expr": "plotWidth"}, "h": {"$-expr": "axisNameFontMaxHeight"}, "r": 0}, "args": {"templateForceText": true}, "textSlots": {"body": {"text": {"$-expr": "xTitle"}, "valign": "middle", "halign": "center", "color": {"$-expr": "fontColor"}, "font": {"$-expr": "font"}, "fontSize": {"$-expr": "titleFontSize"}}}}, {"id": "legend", "$-if": "hasLegend", "shape": "rect", "name": "Legend", "area": {"x": {"$-expr": "padding"}, "y": {"$-expr": "legendTop"}, "w": {"$-expr": "legend.w"}, "h": {"$-expr": "legend.h"}}, "shapeProps": {"fill": {"type": "none"}, "strokeSize": 0, "cornerRadius": 0, "clip": true}, "childItems": [{"$-foreach": {"source": "legend.labels", "it": "label"}, "id": {"$-str": "legend-label-${label.index}"}, "shape": "rect", "name": {"$-expr": "label.name"}, "area": {"x": {"$-expr": "label.x"}, "y": {"$-expr": "label.y + fontSize/2 - 2"}, "w": 15, "h": 5}, "shapeProps": {"cornerRadius": 5, "strokeSize": 0, "fill": {"type": "solid", "color": {"$-expr": "label.color"}}}}, {"$-foreach": {"source": "legend.labels", "it": "label"}, "id": {"$-str": "legend-label-text-${label.index}"}, "shape": "none", "name": {"$-expr": "label.name"}, "area": {"x": {"$-expr": "label.x + 20"}, "y": {"$-expr": "label.y"}, "w": {"$-expr": "max(1, label.w)"}, "h": {"$-expr": "max(1, label.h)"}}, "args": {"templateForceText": true}, "textSlots": {"body": {"text": {"$-expr": "label.name"}, "color": {"$-expr": "fontColor"}, "font": {"$-expr": "font"}, "fontSize": {"$-expr": "fontSize"}, "halign": "left", "valign": "top"}}}]}]}, "init": "struct Path {\n    points: List()\n    closed: false\n    pos: 'relative'\n}\n\nstruct Point {\n    x: 0\n    y: 0\n    t: 'L'\n}\n\nstruct SmoothPoint {\n    x: 0\n    y: 0\n    x1: 0\n    y1: 0\n    x2: 0\n    y2: 0\n    t: 'B'\n}\nstruct Point {\n    x: 0\n    y: 0\n    t: 'L'\n}\n\nstruct SmoothPoint {\n    x: 0\n    y: 0\n    x1: 0\n    y1: 0\n    x2: 0\n    y2: 0\n    t: 'B'\n}\n\nstruct LegendLabel {\n    index: 0\n    name: \"\"\n    color: \"#ff00ffff\"\n    x: 0\n    y: 0\n    w: 1\n    h: 1\n}\n\nstruct Legend {\n    w: 0\n    h: 0\n    labels: List()\n}\n\nstruct AxisLabel {\n    text: \"\"\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n}\n\nstruct AxisLine {\n    value: 0\n    position: 0\n    labelText: \"\"\n}\n\nstruct Axis {\n    lines: List()\n    min: 0\n    max: 100\n    step: 10\n    labels: List()\n}\n\nfunc generateYAxis(softMin, softMax, numTicks, font, fontSize) {\n    numTicks = max(2, numTicks)\n    // Calculate a nice step size\n    local range = softMax - softMin\n    local roughStep = range / (numTicks - 1)\n\n    // Find a \"nice\" step size (1, 2, 5, 10, 20, 50, 100, etc.)\n    local magnitude = 10 ^ floor(log10(roughStep))\n    local normalized = roughStep / magnitude\n\n    local niceStep = 1\n    if (normalized < 1.5) {\n        niceStep = magnitude\n    } else if (normalized < 3.5) {\n        niceStep = 2 * magnitude\n    } else if (normalized < 7.5) {\n        niceStep = 5 * magnitude\n    } else {\n        niceStep = 10 * magnitude\n    }\n\n    // Find nice min and max\n    local niceMin = floor(softMin / niceStep) * niceStep\n    local niceMax = ceil(softMax / niceStep) * niceStep\n\n    local range = abs(niceMax - niceMin)\n\n    // Generate grid lines\n    local lines = List()\n    for (local value = niceMin; value <= niceMax; value += niceStep) {\n        // Normalize position to 0-100% range (0 = bottom, 100% = top)\n        local position = 100 - 100 * (value - niceMin) / max(1, (niceMax - niceMin))\n\n        lines.add(AxisLine(value, position, formatLabel(value, range)))\n    }\n\n    Axis(lines, niceMin, niceMax, niceStep, generateYAxisLabels(lines, font, fontSize))\n}\n\nfunc generateYAxisLabels(lines, font, fontSize) {\n    local labels = List()\n    lines.forEach((line) => {\n        local size = calculateTextSize(line.labelText, font, fontSize)\n        size.w *= 1.1\n        size.h *= 2.2\n\n        labels.add(AxisLabel(line.labelText, 0, line.position,  size.w, size.h))\n    })\n    labels\n}\n\nlocal minPixelDistance = 40\n\n\nfunc generateXAxis(xMin, xMax, xStep, plotOffset, plotWidth, plotHeight, font, fontSize) {\n    local dataRange = max(0.00001, xMax - xMin)\n    local pixelsPerUnit = plotWidth / dataRange\n    local pixelsPerStep = xStep * pixelsPerUnit\n\n    // If the current step is already large enough, use it\n    if (pixelsPerStep >= minPixelDistance) {\n        return _generateXAxis(xMin, xMax, xStep, plotOffset, plotWidth, plotHeight, font, fontSize)\n    } else {\n        local minMultiplier = ceil(minPixelDistance / pixelsPerStep)\n        local optimizedStep = xStep * minMultiplier\n        _generateXAxis(xMin, xMax, optimizedStep, plotOffset, plotWidth, plotHeight, font, fontSize)\n    }\n}\n\nfunc _generateXAxis(xMin, xMax, xStep, plotOffset, plotWidth, plotHeight, font, fontSize) {\n    local lines = List()\n\n    local range = abs(xMax - xMin)\n\n    for (local value = xMin; value <= xMax; value += xStep) {\n        // Normalize position to 0-100 range (0 = left, 100% = right)\n        local position = 100 * (value - xMin) / (xMax - xMin)\n\n        lines.add(AxisLine(value, position, formatLabel(value, range)))\n    }\n\n    Axis(lines, xMin, xMax, xStep, generateXAxisLabels(lines, plotOffset, plotWidth, plotHeight, font, fontSize))\n}\n\nfunc generateXAxisLabels(lines, plotOffset, plotWidth, plotHeight, font, fontSize) {\n    local labels = List()\n    lines.forEach((line, idx) => {\n        local size = calculateTextSize(line.labelText, line.position * plotWidth / 100, plotHeight, font, fontSize)\n        size.w *= 1.1\n        size.h *= 2.2\n        local x = if (idx == 0) {\n            plotOffset + line.position * plotWidth / 100\n        } else if (idx < lines.size - 1) {\n            plotOffset + line.position * plotWidth / 100 - size.w / 2\n        } else {\n            plotOffset + plotWidth - size.w\n        }\n        labels.add(AxisLabel(line.labelText, x, plotHeight, size.w, size.h))\n    })\n    labels\n}\n\nfunc formatLabel(value, range) {\n    // Handle zero\n    if (value == 0) {\n        return '0'\n    }\n\n    // For very small or very large numbers, use scientific notation\n    local absValue = abs(value)\n    if (absValue < 0.001 || absValue > 1000000) {\n        return value.toExponential(2)\n    }\n\n    // Determine decimal places needed based on the range\n    local decimalPlaces = 0\n    if (range < 0.01) {\n        decimalPlaces = 6\n    } else if (range < 0.1) {\n        decimalPlaces = 4\n    } else if (range < 1) {\n        decimalPlaces = 3\n    } else if (range < 10) {\n        decimalPlaces = 2\n    } else if (range < 100) {\n        decimalPlaces = 1\n    }\n\n    // Format and remove trailing zeros\n    parseFloat(value.toFixed(decimalPlaces)).toString()\n}\n\n\nfunc buildLegend(datasets, legendWidth, legendTopMargin) {\n    local maxTextHeight = -1\n    local legendLabels = List()\n\n    local freeSlotWidth = legendWidth\n    local freeSlotY = 0\n    local freeSlotX = 0\n\n    if (datasets.size == 0) {\n        return Legend()\n    }\n\n    local allLabels = datasets.map((dataset, idx) => {\n        local size = calculateTextSize(dataset.name, font, fontSize)\n        size.h *= 2.2\n        if (size.w > legendWidth) {\n            size.w = legendWidth\n        }\n        LegendLabel(\n            idx, dataset.name, dataset.color,\n            0, 0, size.w, size.h\n        )\n    })\n\n    for( ; allLabels.size > 0 ; ) {\n        local label = allLabels.get(0)\n        if (labelIconWidth + label.w <= freeSlotWidth) {\n            label.x = freeSlotX\n            label.y = freeSlotY + legendTopMargin\n\n            legendLabels.add(label)\n            allLabels.shift()\n\n            if (maxTextHeight < label.h) {\n                maxTextHeight = label.h\n            }\n\n            freeSlotX += labelIconWidth + label.w + labelsGap\n            freeSlotWidth = legendWidth - freeSlotX\n        } else {\n            local idx = allLabels.findIndex((label) => { label.w + labelIconWidth <= freeSlotWidth })\n            if (idx >= 0) {\n                local label = allLabels.get(idx)\n                label.x = freeSlotX\n                label.y = freeSlotY + legendTopMargin\n\n                legendLabels.add(label)\n                allLabels.remove(idx)\n\n                if (maxTextHeight < label.h) {\n                    maxTextHeight = label.h\n                }\n\n                freeSlotX += label.w + labelIconWidth + labelsGap\n                freeSlotWidth = legendWidth - freeSlotX\n            } else {\n                freeSlotX = 0\n                if (maxTextHeight > 0) {\n                    freeSlotY += maxTextHeight + 5\n                }\n                freeSlotWidth = legendWidth\n\n                label.x = freeSlotX\n                label.y = freeSlotY + legendTopMargin\n\n                legendLabels.add(label)\n                allLabels.shift()\n\n                freeSlotX += labelIconWidth + label.w + labelsGap\n                freeSlotWidth = legendWidth - freeSlotX\n            }\n        }\n    }\n\n    local legendHeight = min(height/2, legendTopMargin + freeSlotY + maxTextHeight + 5)\n\n    Legend(legendWidth, legendHeight, legendLabels)\n}\n\nlegendTop = 0\nlegendWidth = width - padding * 2\nlegendTopMargin = 10\nlegend = Legend()\ngridPaths = List()\nplotOffset = padding\nplotWidth = max(1, width - padding*2)\nplotHeight = max(1, height - padding*2)\n\nxLabelsFullHeight = 20\n\nlocal size = calculateTextSize(\"TgjW\", font, titleFontSize)\naxisNameFontMaxHeight = size.h * 2\n\n\nlocal labelsGap = 15\nlocal labelIconWidth = 20\nlocal minSpacing = 50\n\n\npointStrokeSize = if (pointType == \"hollow\" || pointType == \"cut\") {\n    2\n} else {\n    0\n}\n\nstruct Dataset {\n    args: 0\n    points: List()\n}\n\n\nif (hasLegend) {\n    legend = buildLegend(datasets, legendWidth, legendTopMargin)\n}\n\n\n\nfunc parseDatasetPoints(encodedPoints, yAxis, plotWidth, plotHeight) {\n    local dx = plotWidth * xStep / max(0.000001, xMax - xMin)\n    local dy = yAxis.max - yAxis.min\n    if (abs(plotHeight / dy) > 100000 || abs(dx) > 10000) {\n        return List()\n    }\n\n    local points = encodedPoints.split(',').map((p, idx) => {\n        local value = parseFloat(p.trim())\n        Point(dx * idx * 100 / plotWidth, (yAxis.max - value) * 100 / dy)\n    })\n\n    if (lineType == 'smooth') {\n        return points.map((p, idx) => {\n            local vdx = dx * 100 / (plotWidth*2)\n            SmoothPoint(p.x, p.y, -vdx, 0, vdx, 0)\n        })\n    } else {\n        return points\n    }\n}\n\n\nfunc onTextUpdate(itemId, item, text) {\n    local legendLabelPrefix = 'legend-label-text-'\n\n    if (itemId == 'axis-title-y') {\n        yTitle = text\n    } else if (itemId == 'axis-title-x') {\n        xTitle = text\n    } else if (itemId.startsWith(legendLabelPrefix)) {\n        text = stripHTML(text.replaceAll('</p>', '</p>\\n')).trim().replaceAll('\\n', '\\\\n')\n        local dataIdx = parseInt(itemId.substring(legendLabelPrefix.length))\n        if (dataIdx < 0 || dataIdx >= datasets.size) {\n            return\n        }\n        datasets.get(dataIdx).name = text\n    }\n}\n\nfunc onDeleteItem(itemId, item) {\n    if (itemId == 'axis-title-y') {\n        yTitleShow = false\n    } else if (itemId == 'axis-title-x') {\n        xTitleShow = false\n    } else if (itemId == 'legend') {\n        hasLegend = false\n    }\n}\n\n\nfunc selectTheme(theme) {\n    if (theme == 'light') {\n        background = '#E8E8E9FF'\n        strokeColor = '#C7C7C7FF'\n        gridColor = '#BDBDBDFF'\n        fontColor = '#333333FF'\n\n        datasets.forEach((dataset) => {\n            local c = decodeColor(dataset.color).hsl()\n            if (c.l > 0.4) {\n                c.l = 0.4\n            }\n            if (c.s < 0.7) {\n                c.s = 0.7\n            }\n            dataset.color = c.rgb().encode()\n        })\n    } else if (theme == 'dark') {\n        background = '#202227FF'\n        strokeColor = '#161717FF'\n        gridColor = '#474766FF'\n        fontColor = '#C9C9CAFF'\n\n        datasets.forEach((dataset) => {\n            local c = decodeColor(dataset.color).hsl()\n            if (c.l < 0.65) {\n                c.l = 0.65\n            }\n            dataset.color = c.rgb().encode()\n        })\n    }\n}\n\n\nplotHeight = max(1, height - padding*2 - legend.h)\n\n// Calculate how many ticks can fit with the minimum spacing\nlocal maxTicks = floor(plotHeight / minSpacing)\nlocal yAxis = generateYAxis(yMin, yMax, max(2, maxTicks), font, axisFontSize)\n\n\nplotOffset = 0\nyAxis.labels.forEach((label) => {\n    plotOffset = max(plotOffset, label.w)\n})\n\nplotOffset += padding\n\nif (yTitleShow) {\n    plotOffset += axisNameFontMaxHeight\n}\n\nyAxis.labels.forEach((label) => { label.w = plotOffset })\n\nplotWidth = max(1, width - plotOffset - padding)\n\nlocal xAxis = generateXAxis(xMin, xMax, xStep, plotOffset, plotWidth, plotHeight, font, axisFontSize)\n\nxAxis.labels.forEach((label) => {\n    xLabelsFullHeight = max(xLabelsFullHeight, label.h)\n})\n\nxTitleK = if (xTitleShow) { 1 } else { 0 }\n\nplotHeight = max(1, height - xLabelsFullHeight - axisNameFontMaxHeight * xTitleK - legend.h - padding)\nyAxis.labels.forEach((label) => { label.y = padding + label.y * plotHeight / 100 - label.h / 2 })\nxAxis.labels.forEach((label) => { label.y = padding + plotHeight })\n\nlegendTop = xLabelsFullHeight + axisNameFontMaxHeight * xTitleK + plotHeight + padding\n\n// generating plot grid paths\nyAxis.lines.forEach((line) => {\n    gridPaths.add(Path(List(Point(0, line.position), Point(100, line.position))))\n})\nxAxis.lines.forEach((line) => {\n    gridPaths.add(Path(List(Point(line.position, 0), Point(line.position, 100))))\n})\n\n\nparsedDatasets = datasets.map((dataset) => {\n    Dataset(dataset, parseDatasetPoints(dataset.values, yAxis, plotWidth, plotHeight))\n})\n\nlocal baseScriptForFunctions = `\nstruct Point {\n    x: 0\n    y: 0\n    x1: 0\n    y1: 0\n    x2: 0\n    y2: 0\n}\n\nlocal xStep = ${xStep}\nlocal xMax = ${xMax}\nlocal xMin = ${xMin}\nlocal yMax = ${yAxis.max}\nlocal yMin = ${yAxis.min}\nlocal lineType = \"${lineType}\"\n\nlocal plot = findChildItemsByTag('chart-plot').find((x) => { x.getShape() == 'path' })\nlocal plotWidth = plot.getWidth()\nlocal plotHeight = plot.getHeight()\nlocal dy = yMax - yMin\nlocal dx = plotWidth * xStep / max(0.000001, xMax - xMin)\n\n\nfunc smoothenPoints(points) {\n    points.forEach((p, idx) => {\n        p.x1 = -dx/2\n        p.y1 = 0\n        p.x2 = dx/2\n        p.y2 = 0\n    })\n}\n\nfunc changePointsInAnimation(pathItem, srcPoints, dstPoints, t) {\n    dstPoints.forEach((dstPoint, idx) => {\n        local srcPoint = srcPoints.get(idx)\n        local x = srcPoint.x * (1 - t) + dstPoint.x * t\n        local y = srcPoint.y * (1 - t) + dstPoint.y * t\n        if (lineType == 'smooth') {\n            local x1 = srcPoint.x1 * (1 - t) + dstPoint.x1 * t\n            local y1 = srcPoint.y1 * (1 - t) + dstPoint.y1 * t\n            local x2 = srcPoint.x2 * (1 - t) + dstPoint.x2 * t\n            local y2 = srcPoint.y2 * (1 - t) + dstPoint.y2 * t\n            pathItem.setPathBezierPointPos(0, idx, x, y, x1, y1, x2, y2)\n        } else {\n            pathItem.setPathPointPos(0, idx, x, y)\n        }\n    })\n}\n`\n\n"}