{"name": "Mind map", "description": "", "args": {"nodes": {"type": "string", "value": "root;x=0;y=0;s=uml_start", "name": "Nodes encoded", "hidden": true}, "connectorType": {"type": "choice", "value": "smooth", "options": ["linear", "smooth", "step", "step-cut", "step-smooth"], "name": "Connectors Type"}, "capType": {"type": "path-cap", "value": "triangle", "name": "Cap type"}, "capSize": {"type": "number", "value": 15, "name": "Cap size"}, "iconSize": {"type": "number", "value": 20, "name": "Icon size"}, "showProgress": {"type": "boolean", "value": false, "name": "Show Progress"}, "progressSize": {"type": "number", "value": 20, "name": "Progress Icon Size", "depends": {"showProgress": true}}, "progressColor": {"type": "color", "value": "#81BDFB", "name": "Progress Icon Color", "depends": {"showProgress": true}}, "progressColor2": {"type": "color", "value": "#13D481", "name": "Progress Icon Color 2", "depends": {"showProgress": true}}}, "preview": "/assets/templates/previews/mind-map.svg", "defaultArea": {"x": 0, "y": 0, "w": 200, "h": 60}, "import": ["./src/treenode.sch", "./src/item.sch", "./src/control.sch", "./src/mind-map.sch"], "controls": [{"$-foreach": {"source": "controls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "editor": {"panels": [{"id": "node-progress", "condition": "shouldNodeProgressEditorBeDisplayed(selectedItemIds)", "type": "slot-menu", "click": "selectProgressForItems(selectedItemIds, panelItem)", "name": "Select progress", "slotSize": {"width": {"$-expr": "progressSize * 2"}, "height": {"$-expr": "progressSize * 2"}}, "items": [{"$-foreach": {"source": "getAllProgressIconItems()", "it": "it"}, "$-extend": {"$-expr": "toJSON(it)"}}]}, {"id": "node-icon-selector", "condition": "shouldNodeIconSelectorBeDisplayed(selectedItemIds)", "type": "slot-menu", "click": "selectIconForItems(selectedItemIds, panelItem)", "name": "Choose icons", "slotSize": {"width": 24, "height": 24}, "items": [{"$-foreach": {"source": "getAllAvailableIcons()", "it": "icon"}, "id": {"$-expr": "icon.id"}, "shape": "image", "area": {"x": -2, "y": -2, "w": 18, "h": 18}, "shapeProps": {"image": {"$-expr": "icon.url"}}}]}, {"id": "node-shape-selector", "condition": "shouldNodeShapeSelectorBeDisplayed(selectedItemIds)", "type": "slot-menu", "click": "selectShapeForItems(selectedItemIds, panelItem)", "name": "Select shape", "slotSize": {"width": 80, "height": 40}, "items": [{"id": "rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 0, "fill": {"type": "none"}}}, {"id": "rounded-rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 10, "fill": {"type": "none"}}}, {"id": "start", "shape": "uml_start", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "ellipse", "shape": "ellipse", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 5, "fill": {"type": "none"}}}, {"id": "label", "shape": "none", "area": {"w": 72, "h": 32}, "textSlots": {"body": {"text": "Simple label"}}}]}]}, "item": {"$-recurse": {"object": {"$-expr": "rootItem"}, "it": "it", "children": "it.childItems", "dstChildren": "childItems"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "`${it.name}`"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "it.getArgs()"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, "init": "struct TreeNode {\n    id: uid()\n    data: Map()\n    parent: null\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n    siblingIdx: 0\n    level: 0\n    children: List()\n    tempData: Map()\n\n    findById(nodeId) {\n        if (this.id == nodeId) {\n            this\n        } else {\n            foundNode = null\n            for (i = 0; i < this.children.size && !foundNode; i++) {\n                foundNode = this.children.get(i).findById(nodeId)\n            }\n            foundNode\n        }\n    }\n\n    map(callback) {\n        mappedChildren = List()\n        this.children.forEach((childNode) => {\n            mappedChildren.add(childNode.map(callback))\n        })\n        callback(this, mappedChildren)\n    }\n\n    attachTo(parentNode) {\n        this.parent = parentNode\n        this.siblingIdx = parentNode.children.size\n        parentNode.children.add(this)\n    }\n\n    attachChildAtIndex(childNode, idx) {\n        childNode.parent = this\n        this.children.insert(idx, childNode)\n        this.children.forEach((node, nodeIdx) => {\n            node.siblingIdx = nodeIdx\n        })\n    }\n\n    encodeTree(nodeSeparator, paramSeparator) {\n        encoded = this.id\n        this.data.forEach((value, name) => {\n            encoded = encoded + paramSeparator + name + '=' + value\n        })\n        this.children.forEach((childNode) => {\n            childEncoded = childNode.encodeTree(nodeSeparator, paramSeparator)\n            encoded += nodeSeparator + childEncoded\n        })\n        encoded + nodeSeparator + 'N'\n    }\n\n    reindex(callback) {\n        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }\n        if (this.children.size > 0) {\n            this.children.forEach((childNode) => {\n                childNode.reindex(callback)\n            })\n        }\n        if (callback) {\n            callback(this)\n        }\n    }\n\n    traverse(callback) {\n        callback(this, this.parent)\n        this.children.forEach((childNode) => {\n            childNode.traverse(callback)\n        })\n    }\n}\n\ndecodeTreeNode = (nodeEncoded, paramSeparator) => {\n    nodeParts = splitString(nodeEncoded, paramSeparator)\n    nodeId = nodeParts.shift()\n    nodeData = Map()\n    nodeParts.forEach((encodedParameter) => {\n        paramParts = splitString(encodedParameter, '=')\n        if (paramParts.size == 2) {\n            nodeData.set(paramParts.get(0), paramParts.get(1))\n        }\n    })\n\n    TreeNode(nodeId, nodeData)\n}\n\ndecodeTree = (encodedText, nodeSeparator, paramSeparator) => {\n    nodeList = splitString(encodedText, nodeSeparator)\n    rootNode = decodeTreeNode(nodeList.shift(), paramSeparator)\n    currentNode = rootNode\n    while(nodeList.size > 0) {\n        nodeEncoded = nodeList.shift()\n        if (nodeEncoded == 'N') {\n            parent = currentNode.parent\n            if (!parent) {\n                parent = rootNode\n            }\n            currentNode = parent\n        } else {\n            newNode = decodeTreeNode(nodeEncoded, paramSeparator)\n            newNode.attachTo(currentNode)\n            currentNode = newNode\n        }\n    }\n    rootNode\n}\n\n\n\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n    textSlots: Map()\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n\n    setText(slotName, text) {\n        if (!this.textSlots.has(slotName)) {\n            this.textSlots.set(slotName, Map('text', text))\n        } else {\n            this.textSlots.get(slotName).set('text', text)\n        }\n    }\n\n    toJSON() {\n        childItems = this.childItems.map((childItem) => { childItem.toJSON() })\n        result = toJSON(Map(\n            'id', this.id,\n            'childItems', childItems,\n            'name', this.name,\n            'shape', this.shape,\n            'area', Map('x', this.x, 'y', this.y, 'w', this.w, 'h', this.h, 'r', 0, 'sx', 1, 'sy', 1, 'px', 0.5, 'py', 0.5),\n            'shapeProps', this.shapeProps,\n            'args', this.args,\n            'locked', this.locked,\n            'textSlots', this.textSlots,\n        ))\n\n        result\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n}\n\npadding = 60\ncontrolPadding = 40\ncontrols = List()\n\nallIcons = Map(\n    'search', '/assets/art/google-cloud/bigquery/bigquery.svg',\n    'time', '/assets/art/azure/General/10006-icon-service-Recent.svg',\n    'cloud', '/assets/art/google-cloud/my_cloud/my_cloud.svg',\n    \"check\", \"/assets/art/icons/check.svg\",\n    \"cross\", \"/assets/art/icons/cross.svg\",\n    \"depressed\", \"/assets/art/icons/depressed.svg\",\n    \"emoji-angry\", \"/assets/art/icons/emoji-angry.svg\",\n    \"emoji-angry-2\", \"/assets/art/icons/emoji-angry-2.svg\",\n    \"emoji-cry\", \"/assets/art/icons/emoji-cry.svg\",\n    \"emoji-dead\", \"/assets/art/icons/emoji-dead.svg\",\n    \"emoji-hah\", \"/assets/art/icons/emoji-hah.svg\",\n    \"emoji-happy\", \"/assets/art/icons/emoji-happy.svg\",\n    \"emoji-heart\", \"/assets/art/icons/emoji-heart.svg\",\n    \"emoji-puke\", \"/assets/art/icons/emoji-puke.svg\",\n    \"emoji-rest\", \"/assets/art/icons/emoji-rest.svg\",\n    \"emoji-rest-2\", \"/assets/art/icons/emoji-rest-2.svg\",\n    \"emoji-rich\", \"/assets/art/icons/emoji-rich.svg\",\n    \"emoji-smile\", \"/assets/art/icons/emoji-smile.svg\",\n    \"emoji-smile-2\", \"/assets/art/icons/emoji-smile-2.svg\",\n    \"emoji-suprised\", \"/assets/art/icons/emoji-suprised.svg\",\n    \"emoji-tired\", \"/assets/art/icons/emoji-tired.svg\",\n    \"emoji-wow\", \"/assets/art/icons/emoji-wow.svg\",\n    \"heart\", \"/assets/art/icons/heart.svg\",\n    \"number-0\", \"/assets/art/icons/number-0.svg\",\n    \"number-1\", \"/assets/art/icons/number-1.svg\",\n    \"number-2\", \"/assets/art/icons/number-2.svg\",\n    \"number-3\", \"/assets/art/icons/number-3.svg\",\n    \"number-4\", \"/assets/art/icons/number-4.svg\",\n    \"number-5\", \"/assets/art/icons/number-5.svg\",\n    \"number-6\", \"/assets/art/icons/number-6.svg\",\n    \"number-7\", \"/assets/art/icons/number-7.svg\",\n    \"number-8\", \"/assets/art/icons/number-8.svg\",\n    \"number-9\", \"/assets/art/icons/number-9.svg\",\n    \"question\", \"/assets/art/icons/question.svg\",\n    \"size-l\", \"/assets/art/icons/size-l.svg\",\n    \"size-m\", \"/assets/art/icons/size-m.svg\",\n    \"size-s\", \"/assets/art/icons/size-s.svg\",\n    \"size-xl\", \"/assets/art/icons/size-xl.svg\",\n    \"size-xs\", \"/assets/art/icons/size-xs.svg\",\n    \"warn\", \"/assets/art/icons/warn.svg\",\n)\n\n\nfunc getAllAvailableIcons() {\n    icons = List()\n\n    allIcons.forEach((url, id) => {\n        icons.add(toJSON(Map('id', id, 'url', url)))\n    })\n    icons\n}\n\nfunc getNodeIcons(node) {\n    icons = List()\n    if (node.data.has('icons')) {\n        iconSet = Set()\n        splitString(node.data.get('icons'), ',').forEach((iconId) => {\n            if (iconId && !iconSet.has(iconId)) {\n                icons.add(iconId)\n                iconSet.add(iconId)\n            }\n        })\n    }\n    icons\n}\n\nfunc encodeIcons(icons) {\n    encoded = ''\n    icons.forEach((id, idx) => {\n        if (idx > 0) {\n            encoded += ','\n        }\n        encoded += id\n    })\n    encoded\n}\n\n\nfunc setNodeIcon(node, iconId) {\n    icons = getNodeIcons(node)\n\n    idx = icons.findIndex((id) => { id == iconId })\n    if (idx < 0) {\n        icons.add(iconId)\n    } else {\n        icons.remove(idx)\n    }\n\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nfunc removeNodeIcon(node, iconId) {\n    icons = getNodeIcons(node)\n    idx = icons.findIndex((id) => { id == iconId })\n\n    if (idx >= 0) {\n        icons.remove(idx)\n    }\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nstruct PinPoint {\n    id: 't'\n    x: 0\n    y: 0\n    normal: Vector(0, -1)\n}\n\n// zone points should be arranged in a counter clock wise polygon\nfunc isPointInsideZone(testPoint, zonePoints) {\n    if (zonePoints.size < 3) {\n        false\n    } else {\n        lines = List()\n\n        for (i = 0; i < zonePoints.size - 1; i++) {\n            p1 = zonePoints.get(i)\n            p2 = zonePoints.get(i+1)\n            lines.add(Math.createLineEquation(p2.x, p2.y, p1.x, p1.y))\n        }\n\n        isInZone = true\n        for (i = 0; i < lines.size && isInZone; i++) {\n            if (Math.sideAgainstLine(testPoint.x, testPoint.y, lines.get(i)) < 0) {\n                isInZone = false\n            }\n        }\n        isInZone\n    }\n}\n\n\nfunc getPinPointById(pinId, node) {\n    if (pinId == 't') {\n        PinPoint('t', node.w/2, 0,        Vector(0, -1))\n    } else if (pinId == 'b') {\n        PinPoint('b', node.w/2, node.h,   Vector(0, 1))\n    } else if (pinId == 'l') {\n        PinPoint('l', 0,        node.h/2, Vector(-1, 0))\n    } else if (pinId == 'r') {\n        PinPoint('r', node.w,   node.h/2, Vector(1, 0))\n    }\n}\n\nrootNode = decodeTree(nodes, ' | ', ';')\n\nfunc encodeMindMap() {\n    nodes = rootNode.encodeTree(' | ', ';')\n}\n\nstruct SuggestedConnection {\n    srcPin: null\n    dstPin: null\n    zonePoints: List()\n}\n\nfunc findPinsForNodes(node, child) {\n\n    p1 = Vector(0, 0)\n    p2 = Vector(node.w, 0)\n    p3 = Vector(node.w, node.h)\n    p4 = Vector(0, node.h)\n\n    topRightV    = Vector(1, -3)\n    bottomLeftV  = -topRightV\n    topLeftV     = Vector(-1, -3)\n    bottomRightV = -topLeftV\n\n    srcTopPin    = getPinPointById('t', node)\n    srcBottomPin = getPinPointById('b', node)\n    srcLeftPin   = getPinPointById('l', node)\n    srcRightPin  = getPinPointById('r', node)\n\n    dstTopPin    = getPinPointById('t', child)\n    dstBottomPin = getPinPointById('b', child)\n    dstLeftPin   = getPinPointById('l', child)\n    dstRightPin  = getPinPointById('r', child)\n\n    childOffset = Vector(child.x, child.y)\n\n    t = Vector(node.w/2, 0)\n    t2 = t + Vector(0, -10)\n    b = Vector(node.w/2, node.h)\n    b2 = b + Vector(0, 10)\n\n    connections = List(\n        () => { SuggestedConnection(srcTopPin, dstRightPin, List(p1 + topLeftV, p1, t, t2)) },\n        () => { SuggestedConnection(srcTopPin, dstLeftPin, List(t2, t, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstLeftPin, List(p3 + bottomRightV, p3, b, b2)) },\n        () => { SuggestedConnection(srcBottomPin, dstRightPin, List(b2, b, p4, p4 + bottomLeftV)) },\n\n        () => { SuggestedConnection(srcRightPin, dstLeftPin, List(p2 + topRightV, p2, p3, p3 + bottomRightV)) },\n        () => { SuggestedConnection(srcLeftPin, dstRightPin, List(p4 + bottomLeftV, p4, p1, p1 + topLeftV)) },\n        () => { SuggestedConnection(srcTopPin, dstBottomPin, List(p1 + topLeftV, p1, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstTopPin, List(p3 + bottomRightV, p3, p4, p4 + bottomLeftV)) },\n    )\n\n    srcPin = srcRightPin\n    dstPin = dstLeftPin\n    matches = false\n\n    for (i = 0; i < connections.size && !matches; i++) {\n        connection = connections.get(i)()\n        srcPin = connection.srcPin\n        dstPin = connection.dstPin\n\n        testPoint = Vector(dstPin.x, dstPin.y) + childOffset\n        matches = isPointInsideZone(testPoint, connection.zonePoints)\n    }\n\n    List(srcPin, dstPin)\n}\n\nfunc prepareConnectorForNode(node, parent) {\n    connector = Item(`connector-${parent.id}-${node.id}`, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n\n    x1 = parent.w/2\n    y1 = parent.h/2\n\n    x2 = node.x + node.w/2\n    y2 = node.y + node.h/2\n\n    childOffset = Vector(node.x, node.y)\n\n    pins = findPinsForNodes(parent, node)\n    pin1 = pins.get(0)\n    pin2 = pins.get(1)\n\n    connector.shapeProps.set('points', List(\n        Map('id', pin1.id, 'x', pin1.x, 'y', pin1.y, 'nx', pin1.normal.x, 'ny', pin1.normal.y),\n        Map('id', pin2.id, 'x', pin2.x + childOffset.x, 'y', pin2.y + childOffset.y, 'nx', pin2.normal.x, 'ny', pin2.normal.y)\n    ))\n\n    connector.args.set('templateIgnoredProps', List('name', 'shapeProps.fill', 'shapeProps.stroke*'))\n\n    connector.shapeProps.set('sourceItem', `#${parent.id}`)\n    connector.shapeProps.set('sourcePin', pin1.id)\n    connector.shapeProps.set('destinationItem', `#${node.id}`)\n    connector.shapeProps.set('destinationPin', pin2.id)\n    connector.shapeProps.set('sourceCap', 'empty')\n    connector.shapeProps.set('destinationCap', capType)\n    connector.shapeProps.set('destinationCapSize', capSize)\n    connector.shapeProps.set('smoothing', connectorType)\n\n    if (parent.tempData.has('connectors')) {\n        parent.tempData.get('connectors').add(connector)\n    } else {\n        parent.tempData.set('connectors', List(connector))\n    }\n\n    pin2.id\n}\n\nABS_POS = 'absolutePosition'\n\nfunc updateAbsoluteNodePosition(node) {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    localPos = Vector(x, y)\n\n    pos = (if (node.parent) {\n        if (node.parent.tempData.has(ABS_POS)) {\n            node.parent.tempData.get(ABS_POS) + localPos\n        } else {\n            parentPos = updateAbsoluteNodePosition(node.parent)\n            parentPos + localPos\n        }\n    } else {\n        localPos\n    })\n\n    node.tempData.set(ABS_POS, pos)\n\n    pos\n}\n\n\nrootNode.traverse((node, parent) => {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    w = parseInt(node.data.get('w'))\n    h = parseInt(node.data.get('h'))\n    p = 0\n    if (node.data.has('p')) {\n        p = parseInt(node.data.get('p'))\n    }\n\n    node.data.set('x', x)\n    node.data.set('y', y)\n    node.data.set('w', w)\n    node.data.set('h', h)\n    node.data.set('p', p)\n\n    node.x = x\n    node.y = y\n    pos = updateAbsoluteNodePosition(node)\n\n    addingControl = (location, placement, cx, cy) => {\n        Control(`add_child_${location}`, Map('nodeId', node.id), `createNewChildFor(control.data.nodeId, '${location}')`, cx, cy, 20, 20, '+', placement, node.id)\n    }\n\n    if (parent) {\n        node.w = w\n        node.h = h\n        pinId = prepareConnectorForNode(node, parent)\n        controls.extendList(List(\n            addingControl('top', 'BL', pos.x + node.w / 2 - 10, pos.y - controlPadding),\n            addingControl('bottom', 'TL', pos.x + node.w / 2 - 10, pos.y + node.h + controlPadding),\n            addingControl('left', 'TR', pos.x - controlPadding, pos.y + node.h / 2 - 10),\n            addingControl('right', 'TL', pos.x + node.w + controlPadding, pos.y + node.h / 2 - 10)\n        ).filter((control) => {!control.name.startsWith(`add_child_${pinId}`)}))\n    } else {\n        node.w = width\n        node.h = height\n\n        controls.extendList(List(\n            addingControl('top', 'BL', node.w / 2 - 10, -controlPadding),\n            addingControl('bottom', 'TL', node.w / 2 - 10, node.h + controlPadding),\n            addingControl('left', 'TR', -controlPadding, node.h / 2 - 10),\n            addingControl('right', 'TL', node.w + controlPadding, node.h / 2 - 10)\n        ))\n    }\n})\n\n\nfunc createProgressPaths(percent) {\n    R = 50\n    angle = 2 * Math.PI * percent / 100\n\n    v1 = Vector(0, -50)\n    v2 = v1.rotate(angle)\n\n    p2 = Vector(50, 50) + v2\n\n    L = (Vector(50, 0) - p2).length()\n\n    solution = Math.solveQuadratic(0.5, -R, L*L/8)\n\n    h = 50\n\n    if (solution) {\n        H = 0\n        if (percent <= 50) {\n            H = min(solution.v1, solution.v2)\n        } else {\n            H = max(solution.v1, solution.v2)\n        }\n        h = H / L * 100\n    }\n\n    List(Map(\n        'closed', 'true',\n        'pos', 'relative',\n        'points', List(\n            Map(\n                'id', '1',\n                't', 'L',\n                'x', 50,\n                'y', 50,\n            ),\n            Map(\n                'id', '2',\n                't', 'A',\n                'x', 50,\n                'y', 0,\n                'h', h\n            ),\n            Map(\n                'id', '3',\n                't', 'L',\n                'x', p2.x,\n                'y', p2.y,\n            ),\n        )\n    ))\n}\n\nfunc createProgressIconItems(nodeId, percent, color, x, y) {\n    items = List()\n\n\n    isNotFull = percent < 99.5\n\n    items.add(Item(\n        `${nodeId}_progress_stroke`, 'progress container', 'ellipse', x, y, progressSize, progressSize, Map(\n            'fill', if (isNotFull) { Map('type', 'none') } else { Map('type', 'solid', 'color', color) },\n            'strokeColor', color,\n            'strokeSize', 3\n        ), List(), Map(\n            'mindMapType', 'progress',\n            'mindMapNodeId', nodeId,\n        )\n    ))\n    if (percent > 0.5 && isNotFull) {\n        items.add(Item(\n            `${nodeId}_progress`, 'progress', 'path', x, y, progressSize, progressSize, Map(\n                'paths', createProgressPaths(percent),\n                'strokeSize', 0,\n                'strokeColor', color,\n                'fill', Map('type', 'solid', 'color', color)\n            ), List(), Map(\n                'mindMapType', 'progress',\n                'mindMapNodeId', nodeId,\n            )\n        ))\n    }\n    items\n}\n\nfunc createNodeIconItems(node) {\n    items = List()\n\n    margin = 5\n\n    if (showProgress) {\n        percent = 0\n        color = progressColor\n        if (node.children.size == 0) {\n            color = progressColor2\n        }\n        if (node.data.has('p')) {\n            percent = parseInt(node.data.get('p'))\n        }\n        x = 10\n        y = node.h / 2 - progressSize / 2\n\n        items.extendList(createProgressIconItems(node.id, percent, color, x, y))\n    }\n\n    progressOffset = if (showProgress) { margin + progressSize } else { 0 }\n\n    getNodeIcons(node).forEach((iconId, idx) => {\n        x = (iconSize + margin) * idx + 10 + progressOffset\n        y = node.h / 2 - iconSize / 2\n        items.add(Item(\n            `${node.id}_icon_${iconId}`, iconId, 'image', x, y, iconSize, iconSize, Map('image', allIcons.get(iconId)), List(), Map(\n                'mindMapType', 'icon',\n                'mindMapIcon', iconId,\n                'mindMapNodeId', node.id,\n            )\n        ))\n    })\n\n    items\n}\n\nrootItem = rootNode.map((node, childItems) => {\n    x = node.data.get('x')\n    y = node.data.get('y')\n    w = node.data.get('w')\n    h = node.data.get('h')\n\n    childItems.extendList(createNodeIconItems(node))\n\n    if (node.tempData.has('connectors')) {\n        childItems.extendList(node.tempData.get('connectors'))\n    }\n\n    shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n    item = Item(node.id, `item ${node.id}`, shape, x, y, w, h, Map(), childItems, Map(\n        'mindMapType', 'node'\n    ))\n    item.args.set('templateIgnoredProps', List('name', 'shape', 'shapeProps.*'))\n    item.locked = false\n    if (node.id != rootNode.id) {\n        item.args.set('tplArea', 'controlled')\n    }\n    item.args.set('tplRotation', 'off')\n    item.args.set('tplConnector', 'off')\n\n    if (shape == 'none') {\n        item.setText('body', 'Add your text...')\n    }\n    item\n})\n\nrootItem.name = 'Mind map'\nrootItem.w = width\nrootItem.h = height\n\n\nfunc createNewChildFor(nodeId, placement) {\n    node = rootNode.findById(nodeId)\n    if (node) {\n        x = 0\n        y = 0\n        w = max(1, node.w)\n        h = max(1, node.h)\n        shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n        if (placement == 'top') {\n            y = - padding - h\n            x = node.w / 2 - w / 2\n        } else if (placement == 'bottom') {\n            y = node.h + padding\n            x = node.w / 2 - w / 2\n        } else if (placement == 'left') {\n            x = - padding - w\n            y = node.h / 2 - h / 2\n        } else if (placement == 'right') {\n            x = node.w + padding\n            y = node.h / 2 - h / 2\n        }\n\n        childNode = TreeNode(uid(), Map('x', x, 'y', y, 'w', w, 'h', h, 's', shape))\n        node.children.add(childNode)\n\n        encodeMindMap()\n    }\n}\n\n// triggered when item area changes as a result of edit box modifications\n// the handler is supposed to mutate the area object in case the area is changed\non('area', (itemId, item, area) => {\n    node = rootNode.findById(itemId)\n    if (node) {\n        node.data.set('x', area.x)\n        node.data.set('y', area.y)\n        node.data.set('w', area.w)\n        node.data.set('h', area.h)\n        encodeMindMap()\n    }\n})\n\non('delete', (itemId, item) => {\n    if (item.args.mindMapType == 'icon') {\n        node = rootNode.findById(item.args.mindMapNodeId)\n        if (node) {\n            removeNodeIcon(node, item.args.mindMapIcon)\n        }\n    } else if (item.args.mindMapType == 'node') {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            node.parent.children.remove(node.siblingIdx)\n            encodeMindMap()\n        }\n    }\n})\n\nfunc shouldNodeShapeSelectorBeDisplayed(selectedItemIds) {\n    shown = false\n    selectedItemIds.forEach((itemId) => {\n        if (rootNode.findById(itemId)) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc selectShapeForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        updateItem(itemId, (item) => {\n            item.shape = panelItem.shape\n            forEach(panelItem.shapeProps, (value, name) => {\n                if (name != 'fill') {\n                    setObjectField(item.shapeProps, name, value)\n                }\n            })\n            node = rootNode.findById(itemId)\n            if (node) {\n                node.data.set('s', panelItem.shape)\n                encodeMindMap()\n            }\n\n            if (panelItem.shape == 'none') {\n                if (!item.textSlots.body) {\n                    setObjectField(item.textSlots, 'body', toJSON(Map('text', 'Add your text...')))\n                }\n                if (item.textSlots.body) {\n                    if (!item.textSlots.body.text || item.textSlots.body.text == '<p></p>') {\n                        setObjectField(item.textSlots.body, 'text', 'Ad your text...')\n                    }\n                }\n            }\n        })\n    })\n}\n\nfunc shouldNodeIconSelectorBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n}\n\n\nfunc selectIconForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node) {\n            setNodeIcon(node, panelItem.id)\n        }\n    })\n}\n\nfunc shouldNodeProgressEditorBeDisplayed(selectedItemIds) {\n    if (showProgress) {\n        showPanel = false\n        selectedItemIds.forEach((itemId) => {\n            node = rootNode.findById(itemId)\n            if (node && node.children.size == 0) {\n                showPanel = true\n            }\n        })\n        showPanel\n    } else {\n        false\n    }\n}\n\nfunc getAllProgressIconItems() {\n    List(0, 25, 50, 75, 100).map((percent) => {\n        items = createProgressIconItems(`icon-${percent}`, percent, progressColor2, 0, 0)\n        Item(`progress_${percent}_container`, `${percent}`, 'none', 2, 2, progressSize, progressSize, Map(), items, Map(\n            'mindMapProgress', percent\n        )).toJSON()\n    })\n}\n\nfunc selectProgressForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node && node.children.size == 0) {\n            node.data.set('p', panelItem.args.mindMapProgress)\n        }\n    })\n\n    updateProgress = (node) => {\n        log()\n        if (node.children.size > 0) {\n            sumProgress = 0\n            node.children.forEach((childNode) => {\n                sumProgress += updateProgress(childNode)\n            })\n\n            totalProgress = sumProgress / node.children.size\n            node.data.set('p', totalProgress)\n            totalProgress\n        } else {\n            node.data.get('p')\n        }\n    }\n\n    updateProgress(rootNode)\n\n    encodeMindMap()\n}\n\n"}