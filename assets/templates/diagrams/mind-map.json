{"name": "Mind map", "description": "", "args": {"nodes": {"type": "string", "value": "root;x=0;y=0;s=uml_start", "name": "Nodes encoded", "hidden": true}, "connectorType": {"type": "choice", "value": "smooth", "options": ["linear", "smooth", "step", "step-cut", "step-smooth"], "name": "Connectors Type"}, "capType": {"type": "path-cap", "value": "triangle", "name": "Cap type"}, "capSize": {"type": "number", "value": 15, "name": "Cap size"}, "iconSize": {"type": "number", "value": 20, "name": "Icon size"}, "showProgress": {"type": "boolean", "value": false, "name": "Show Progress"}, "progressSize": {"type": "number", "value": 20, "name": "Progress Icon Size", "depends": {"showProgress": true}}, "gradientProgress": {"type": "boolean", "value": true, "name": "Gradient Progress", "depends": {"showProgress": true}}, "progressColor": {"type": "color", "value": "#F35B3B", "name": "Progress Icon Color", "depends": {"showProgress": true}}, "progressColor2": {"type": "color", "value": "#E5AB2D", "name": "Progress Icon Color 2", "depends": {"showProgress": true}}, "progressColor3": {"type": "color", "value": "#13D481", "name": "Progress Icon Color 3", "depends": {"showProgress": true, "gradientProgress": true}}}, "preview": "/assets/templates/previews/mind-map.svg", "defaultArea": {"x": 0, "y": 0, "w": 200, "h": 60}, "import": ["./src/treenode.sch", "./src/item.sch", "./src/control.sch", "./src/mind-map.sch"], "handlers": {"delete": "onDeleteItem(itemId, item)", "area": "onAreaUpdate(itemId, item, area)", "copy": "onCopyItem(itemId, item)", "paste": "onPasteItems(itemId, items)"}, "controls": [{"$-foreach": {"source": "controls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "editor": {"panels": [{"id": "node-progress", "condition": "shouldNodeProgressEditorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectProgressForItems(selectedItemIds, panelItem)", "name": "Select progress", "slotSize": {"width": {"$-expr": "progressSize * 2"}, "height": {"$-expr": "progressSize * 2"}}, "items": [{"$-foreach": {"source": "getAllProgressIconItems()", "it": "it"}, "$-extend": {"$-expr": "toJSON(it)"}}]}, {"id": "node-icon-selector", "condition": "shouldNodeIconSelectorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectIconForItems(selectedItemIds, panelItem)", "name": "Choose icons", "slotSize": {"width": 30, "height": 30}, "items": [{"$-foreach": {"source": "getAllAvailableIcons()", "it": "icon"}, "id": {"$-expr": "icon.id"}, "shape": "image", "area": {"x": -2, "y": -2, "w": 26, "h": 26}, "shapeProps": {"image": {"$-expr": "icon.url"}}}]}, {"id": "node-shape-selector", "condition": "shouldNodeShapeSelectorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectShapeForItems(selectedItemIds, panelItem)", "name": "Select shape", "slotSize": {"width": 80, "height": 40}, "items": [{"id": "rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 0, "fill": {"type": "none"}}}, {"id": "rounded-rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 10, "fill": {"type": "none"}}}, {"id": "start", "shape": "uml_start", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "ellipse", "shape": "ellipse", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 5, "fill": {"type": "none"}}}, {"id": "basic_diamond", "shape": "basic_diamond", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "uml_preparation", "shape": "uml_preparation", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "label", "shape": "none", "area": {"w": 72, "h": 32}, "textSlots": {"body": {"text": "Simple label"}}}]}, {"id": "node-operations", "condition": "shouldNodeOperationsPanelBeDisplayed(selectedItemIds)", "type": "buttons", "name": "Operations", "click": "onOperationsPanelClick(selectedItemIds, panelItem)", "buttons": [{"id": "insert-new-parent", "name": "Insert new parent"}, {"id": "delete-node-preserve-children", "name": "Delete (preserve children)"}]}]}, "item": {"$-recurse": {"object": {"$-expr": "rootItem"}, "it": "it", "children": "it.childItems", "dstChildren": "childItems"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "`${it.name}`"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "it.getArgs()"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, "init": "struct TreeNode {\n    id: uid()\n    data: Map()\n    parent: null\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n    siblingIdx: 0\n    level: 0\n    children: List()\n    tempData: Map()\n\n    findById(nodeId) {\n        if (this.id == nodeId) {\n            this\n        } else {\n            local foundNode = null\n            for (i = 0; i < this.children.size && !foundNode; i++) {\n                foundNode = this.children.get(i).findById(nodeId)\n            }\n            foundNode\n        }\n    }\n\n    map(callback) {\n        local mappedChildren = List()\n        this.children.forEach((childNode) => {\n            mappedChildren.add(childNode.map(callback))\n        })\n        callback(this, mappedChildren)\n    }\n\n    attachTo(parentNode) {\n        this.parent = parentNode\n        this.siblingIdx = parentNode.children.size\n        parentNode.children.add(this)\n    }\n\n    attachChildAtIndex(childNode, idx) {\n        childNode.parent = this\n        this.children.insert(idx, childNode)\n        this.children.forEach((node, nodeIdx) => {\n            node.siblingIdx = nodeIdx\n        })\n    }\n\n    encodeTree(nodeSeparator, paramSeparator) {\n        local encoded = this.id\n        this.data.forEach((value, name) => {\n            encoded = encoded + paramSeparator + name + '=' + value\n        })\n        this.children.forEach((childNode) => {\n            childEncoded = childNode.encodeTree(nodeSeparator, paramSeparator)\n            encoded += nodeSeparator + childEncoded\n        })\n        encoded + nodeSeparator + 'N'\n    }\n\n    reindex(callback) {\n        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }\n        if (this.children.size > 0) {\n            this.children.forEach((childNode) => {\n                childNode.reindex(callback)\n            })\n        }\n        if (callback) {\n            callback(this)\n        }\n    }\n\n    traverse(callback) {\n        callback(this, this.parent)\n        this.children.forEach((childNode) => {\n            childNode.traverse(callback)\n        })\n    }\n}\n\nfunc decodeTreeNode(nodeEncoded, paramSeparator) {\n    local nodeParts = splitString(nodeEncoded, paramSeparator)\n    local nodeId = nodeParts.shift()\n    local nodeData = Map()\n\n    nodeParts.forEach((encodedParameter) => {\n        paramParts = splitString(encodedParameter, '=')\n        if (paramParts.size == 2) {\n            nodeData.set(paramParts.get(0), paramParts.get(1))\n        }\n    })\n\n    TreeNode(nodeId, nodeData)\n}\n\nfunc decodeTree(encodedText, nodeSeparator, paramSeparator) {\n    local nodeList = splitString(encodedText, nodeSeparator)\n    local rootNode = decodeTreeNode(nodeList.shift(), paramSeparator)\n    local currentNode = rootNode\n    while(nodeList.size > 0) {\n        nodeEncoded = nodeList.shift()\n        if (nodeEncoded == 'N') {\n            parent = currentNode.parent\n            if (!parent) {\n                parent = rootNode\n            }\n            currentNode = parent\n        } else {\n            newNode = decodeTreeNode(nodeEncoded, paramSeparator)\n            newNode.attachTo(currentNode)\n            currentNode = newNode\n        }\n    }\n    rootNode\n}\n\n\n\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n    textSlots: Map()\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n\n    setText(slotName, text) {\n        if (!this.textSlots.has(slotName)) {\n            this.textSlots.set(slotName, Map('text', text))\n        } else {\n            this.textSlots.get(slotName).set('text', text)\n        }\n    }\n\n    toJSON() {\n        childItems = this.childItems.map((childItem) => { childItem.toJSON() })\n        result = toJSON(Map(\n            'id', this.id,\n            'childItems', childItems,\n            'name', this.name,\n            'shape', this.shape,\n            'area', Map('x', this.x, 'y', this.y, 'w', this.w, 'h', this.h, 'r', 0, 'sx', 1, 'sy', 1, 'px', 0.5, 'py', 0.5),\n            'shapeProps', this.shapeProps,\n            'args', this.args,\n            'locked', this.locked,\n            'textSlots', this.textSlots,\n        ))\n\n        result\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n}\n\npadding = 60\ncontrolPadding = 40\ncontrols = List()\nrootNode = null\nABS_POS = 'absolutePosition'\n\n// rootItem is used for building all of the template items\nrootItem = null\n\nallIcons = Map(\n    'search', '/assets/art/google-cloud/bigquery/bigquery.svg',\n    'time', '/assets/art/azure/General/10006-icon-service-Recent.svg',\n    'cloud', '/assets/art/google-cloud/my_cloud/my_cloud.svg',\n    \"check\", \"/assets/art/icons/check.svg\",\n    \"cross\", \"/assets/art/icons/cross.svg\",\n    \"depressed\", \"/assets/art/icons/depressed.svg\",\n    \"emoji-angry\", \"/assets/art/icons/emoji-angry.svg\",\n    \"emoji-angry-2\", \"/assets/art/icons/emoji-angry-2.svg\",\n    \"emoji-cry\", \"/assets/art/icons/emoji-cry.svg\",\n    \"emoji-dead\", \"/assets/art/icons/emoji-dead.svg\",\n    \"emoji-hah\", \"/assets/art/icons/emoji-hah.svg\",\n    \"emoji-happy\", \"/assets/art/icons/emoji-happy.svg\",\n    \"emoji-heart\", \"/assets/art/icons/emoji-heart.svg\",\n    \"emoji-puke\", \"/assets/art/icons/emoji-puke.svg\",\n    \"emoji-rest\", \"/assets/art/icons/emoji-rest.svg\",\n    \"emoji-rest-2\", \"/assets/art/icons/emoji-rest-2.svg\",\n    \"emoji-rich\", \"/assets/art/icons/emoji-rich.svg\",\n    \"emoji-smile\", \"/assets/art/icons/emoji-smile.svg\",\n    \"emoji-smile-2\", \"/assets/art/icons/emoji-smile-2.svg\",\n    \"emoji-suprised\", \"/assets/art/icons/emoji-suprised.svg\",\n    \"emoji-tired\", \"/assets/art/icons/emoji-tired.svg\",\n    \"emoji-wow\", \"/assets/art/icons/emoji-wow.svg\",\n    \"heart\", \"/assets/art/icons/heart.svg\",\n    \"number-0\", \"/assets/art/icons/number-0.svg\",\n    \"number-1\", \"/assets/art/icons/number-1.svg\",\n    \"number-2\", \"/assets/art/icons/number-2.svg\",\n    \"number-3\", \"/assets/art/icons/number-3.svg\",\n    \"number-4\", \"/assets/art/icons/number-4.svg\",\n    \"number-5\", \"/assets/art/icons/number-5.svg\",\n    \"number-6\", \"/assets/art/icons/number-6.svg\",\n    \"number-7\", \"/assets/art/icons/number-7.svg\",\n    \"number-8\", \"/assets/art/icons/number-8.svg\",\n    \"number-9\", \"/assets/art/icons/number-9.svg\",\n    \"question\", \"/assets/art/icons/question.svg\",\n    \"size-l\", \"/assets/art/icons/size-l.svg\",\n    \"size-m\", \"/assets/art/icons/size-m.svg\",\n    \"size-s\", \"/assets/art/icons/size-s.svg\",\n    \"size-xl\", \"/assets/art/icons/size-xl.svg\",\n    \"size-xs\", \"/assets/art/icons/size-xs.svg\",\n    \"warn\", \"/assets/art/icons/warn.svg\",\n)\n\n\nfunc getAllAvailableIcons() {\n    local icons = List()\n\n    allIcons.forEach((url, id) => {\n        icons.add(toJSON(Map('id', id, 'url', url)))\n    })\n    icons\n}\n\nfunc getNodeIcons(node) {\n    local icons = List()\n    if (node.data.has('icons')) {\n        local iconSet = Set()\n        splitString(node.data.get('icons'), ',').forEach((iconId) => {\n            if (iconId && !iconSet.has(iconId)) {\n                icons.add(iconId)\n                iconSet.add(iconId)\n            }\n        })\n    }\n    icons\n}\n\nfunc encodeIcons(icons) {\n    local encoded = ''\n    icons.forEach((id, idx) => {\n        if (idx > 0) {\n            encoded += ','\n        }\n        encoded += id\n    })\n    encoded\n}\n\n\nfunc setNodeIcon(node, iconId) {\n    local icons = getNodeIcons(node)\n\n    local idx = icons.findIndex((id) => { id == iconId })\n    if (idx < 0) {\n        icons.add(iconId)\n    } else {\n        icons.remove(idx)\n    }\n\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nfunc removeNodeIcon(node, iconId) {\n    local icons = getNodeIcons(node)\n    local idx = icons.findIndex((id) => { id == iconId })\n\n    if (idx >= 0) {\n        icons.remove(idx)\n    }\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nstruct PinPoint {\n    id: 't'\n    x: 0\n    y: 0\n    normal: Vector(0, -1)\n}\n\n// zone points should be arranged in a counter clock wise polygon\nfunc isPointInsideZone(testPoint, zonePoints) {\n    if (zonePoints.size < 3) {\n        false\n    } else {\n        local lines = List()\n\n        for (i = 0; i < zonePoints.size - 1; i++) {\n            local p1 = zonePoints.get(i)\n            local p2 = zonePoints.get(i+1)\n            lines.add(Math.createLineEquation(p2.x, p2.y, p1.x, p1.y))\n        }\n\n        local isInZone = true\n        for (i = 0; i < lines.size && isInZone; i++) {\n            if (Math.sideAgainstLine(testPoint.x, testPoint.y, lines.get(i)) < 0) {\n                isInZone = false\n            }\n        }\n        isInZone\n    }\n}\n\n\nfunc getPinPointById(pinId, node) {\n    if (pinId == 't') {\n        PinPoint('t', node.w/2, 0,        Vector(0, -1))\n    } else if (pinId == 'b') {\n        PinPoint('b', node.w/2, node.h,   Vector(0, 1))\n    } else if (pinId == 'l') {\n        PinPoint('l', 0,        node.h/2, Vector(-1, 0))\n    } else if (pinId == 'r') {\n        PinPoint('r', node.w,   node.h/2, Vector(1, 0))\n    }\n}\n\n\nfunc encodeMindMap() {\n    nodes = rootNode.encodeTree(' | ', ';')\n}\n\nstruct SuggestedConnection {\n    srcPin: null\n    dstPin: null\n    zonePoints: List()\n}\n\nfunc findPinsForNodes(node, child) {\n    local p1 = Vector(0, 0)\n    local p2 = Vector(node.w, 0)\n    local p3 = Vector(node.w, node.h)\n    local p4 = Vector(0, node.h)\n\n    local topRightV    = Vector(1, -3)\n    local bottomLeftV  = -topRightV\n    local topLeftV     = Vector(-1, -3)\n    local bottomRightV = -topLeftV\n\n    local srcTopPin    = getPinPointById('t', node)\n    local srcBottomPin = getPinPointById('b', node)\n    local srcLeftPin   = getPinPointById('l', node)\n    local srcRightPin  = getPinPointById('r', node)\n\n    local dstTopPin    = getPinPointById('t', child)\n    local dstBottomPin = getPinPointById('b', child)\n    local dstLeftPin   = getPinPointById('l', child)\n    local dstRightPin  = getPinPointById('r', child)\n\n    local childOffset = Vector(child.x, child.y)\n\n    local t = Vector(node.w/2, 0)\n    local t2 = t + Vector(0, -10)\n    local b = Vector(node.w/2, node.h)\n    local b2 = b + Vector(0, 10)\n\n    local connections = List(\n        () => { SuggestedConnection(srcTopPin, dstRightPin, List(p1 + topLeftV, p1, t, t2)) },\n        () => { SuggestedConnection(srcTopPin, dstLeftPin, List(t2, t, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstLeftPin, List(p3 + bottomRightV, p3, b, b2)) },\n        () => { SuggestedConnection(srcBottomPin, dstRightPin, List(b2, b, p4, p4 + bottomLeftV)) },\n\n        () => { SuggestedConnection(srcRightPin, dstLeftPin, List(p2 + topRightV, p2, p3, p3 + bottomRightV)) },\n        () => { SuggestedConnection(srcLeftPin, dstRightPin, List(p4 + bottomLeftV, p4, p1, p1 + topLeftV)) },\n        () => { SuggestedConnection(srcTopPin, dstBottomPin, List(p1 + topLeftV, p1, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstTopPin, List(p3 + bottomRightV, p3, p4, p4 + bottomLeftV)) },\n    )\n\n    local srcPin = srcRightPin\n    local dstPin = dstLeftPin\n    local matches = false\n\n    for (local i = 0; i < connections.size && !matches; i++) {\n        local connection = connections.get(i)()\n        srcPin = connection.srcPin\n        dstPin = connection.dstPin\n\n        local testPoint = Vector(dstPin.x, dstPin.y) + childOffset\n        matches = isPointInsideZone(testPoint, connection.zonePoints)\n    }\n\n    List(srcPin, dstPin)\n}\n\nfunc prepareConnectorForNode(node, parent) {\n    local connector = Item(`connector-${parent.id}-${node.id}`, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n\n    local x1 = parent.w/2\n    local y1 = parent.h/2\n\n    local x2 = node.x + node.w/2\n    local y2 = node.y + node.h/2\n\n    local childOffset = Vector(node.x, node.y)\n\n    local pins = findPinsForNodes(parent, node)\n    local pin1 = pins.get(0)\n    local pin2 = pins.get(1)\n\n    connector.shapeProps.set('points', List(\n        Map('id', pin1.id, 'x', pin1.x, 'y', pin1.y, 'nx', pin1.normal.x, 'ny', pin1.normal.y),\n        Map('id', pin2.id, 'x', pin2.x + childOffset.x, 'y', pin2.y + childOffset.y, 'nx', pin2.normal.x, 'ny', pin2.normal.y)\n    ))\n\n    connector.args.set('templateIgnoredProps', List('name', 'shapeProps.fill', 'shapeProps.stroke*'))\n\n    connector.shapeProps.set('sourceItem', `#${parent.id}`)\n    connector.shapeProps.set('sourcePin', pin1.id)\n    connector.shapeProps.set('destinationItem', `#${node.id}`)\n    connector.shapeProps.set('destinationPin', pin2.id)\n    connector.shapeProps.set('sourceCap', 'empty')\n    connector.shapeProps.set('destinationCap', capType)\n    connector.shapeProps.set('destinationCapSize', capSize)\n    connector.shapeProps.set('smoothing', connectorType)\n\n    if (parent.tempData.has('connectors')) {\n        parent.tempData.get('connectors').add(connector)\n    } else {\n        parent.tempData.set('connectors', List(connector))\n    }\n\n    pin2.id\n}\n\n\nfunc updateAbsoluteNodePosition(node) {\n    local x = parseInt(node.data.get('x'))\n    local y = parseInt(node.data.get('y'))\n    local localPos = Vector(x, y)\n\n    local pos = (if (node.parent) {\n        if (node.parent.tempData.has(ABS_POS)) {\n            node.parent.tempData.get(ABS_POS) + localPos\n        } else {\n            parentPos = updateAbsoluteNodePosition(node.parent)\n            parentPos + localPos\n        }\n    } else {\n        localPos\n    })\n\n    node.tempData.set(ABS_POS, pos)\n\n    pos\n}\n\n\nfunc createProgressPaths(percent) {\n    local R = 50\n    local angle = 2 * Math.PI * percent / 100\n\n    local v1 = Vector(0, -50)\n    local v2 = v1.rotate(angle)\n\n    local p2 = Vector(50, 50) + v2\n\n    local L = (Vector(50, 0) - p2).length()\n\n    local solution = Math.solveQuadratic(0.5, -R, L*L/8)\n\n    local h = 50\n\n    if (solution) {\n        local H = 0\n        if (percent <= 50) {\n            H = min(solution.v1, solution.v2)\n        } else {\n            H = max(solution.v1, solution.v2)\n        }\n        h = H / L * 100\n    }\n\n    List(Map(\n        'closed', 'true',\n        'pos', 'relative',\n        'points', List(\n            Map(\n                'id', '1',\n                't', 'L',\n                'x', 50,\n                'y', 50,\n            ),\n            Map(\n                'id', '2',\n                't', 'A',\n                'x', 50,\n                'y', 0,\n                'h', h\n            ),\n            Map(\n                'id', '3',\n                't', 'L',\n                'x', p2.x,\n                'y', p2.y,\n            ),\n        )\n    ))\n}\n\nfunc createProgressIconItems(nodeId, percent, color, x, y) {\n    local items = List()\n\n    if (gradientProgress) {\n        local t = if (percent <= 50) { percent / 50 } else { (percent - 50) / 50 }\n        local c1 = decodeColor(if (percent <= 50) { (progressColor) } else { progressColor2 })\n        local c2 = decodeColor(if (percent <= 50) { (progressColor2) } else { progressColor3 })\n        color = c1.gradient(c2, t).encode()\n    }\n\n    local isNotFull = percent < 99.5\n\n    items.add(Item(\n        `${nodeId}_progress_stroke`, 'progress container', 'ellipse', x, y, progressSize, progressSize, Map(\n            'fill', if (isNotFull) { Map('type', 'none') } else { Map('type', 'solid', 'color', color) },\n            'strokeColor', color,\n            'strokeSize', 3\n        ), List(), Map(\n            'mindMapType', 'progress',\n            'mindMapNodeId', nodeId,\n        )\n    ))\n    if (percent > 0.5 && isNotFull) {\n        items.add(Item(\n            `${nodeId}_progress`, 'progress', 'path', x, y, progressSize, progressSize, Map(\n                'paths', createProgressPaths(percent),\n                'strokeSize', 0,\n                'strokeColor', color,\n                'fill', Map('type', 'solid', 'color', color)\n            ), List(), Map(\n                'mindMapType', 'progress',\n                'mindMapNodeId', nodeId,\n            )\n        ))\n    }\n    items\n}\n\nfunc createNodeIconItems(node) {\n    local items = List()\n\n    local margin = 5\n\n    if (showProgress) {\n        local percent = 0\n        local color = progressColor\n        if (node.children.size == 0) {\n            color = progressColor2\n        }\n        if (node.data.has('p')) {\n            percent = max(0, min(parseInt(node.data.get('p')), 100))\n        }\n        local x = 10\n        local y = node.h / 2 - progressSize / 2\n\n        items.extendList(createProgressIconItems(node.id, percent, color, x, y))\n    }\n\n    local progressOffset = if (showProgress) { margin + progressSize } else { 0 }\n\n    getNodeIcons(node).forEach((iconId, idx) => {\n        local x = (iconSize + margin) * idx + 10 + progressOffset\n        local y = node.h / 2 - iconSize / 2\n        items.add(Item(\n            `${node.id}_icon_${iconId}`, iconId, 'image', x, y, iconSize, iconSize, Map('image', allIcons.get(iconId)), List(), Map(\n                'mindMapType', 'icon',\n                'mindMapIcon', iconId,\n                'mindMapNodeId', node.id,\n            )\n        ))\n    })\n\n    items\n}\n\nfunc buildTemplateItems(rootNode) {\n    rootNode.map((node, childItems) => {\n        local x = node.data.get('x')\n        local y = node.data.get('y')\n        local w = node.data.get('w')\n        local h = node.data.get('h')\n\n        childItems.extendList(createNodeIconItems(node))\n\n        if (node.tempData.has('connectors')) {\n            childItems.extendList(node.tempData.get('connectors'))\n        }\n\n        local shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n        local item = Item(node.id, `item ${node.id}`, shape, x, y, w, h, Map(), childItems, Map(\n            'mindMapType', 'node'\n        ))\n\n        if (node.tempData.has('sourceItem')) {\n            srcItem = node.tempData.get('sourceItem')\n            if (srcItem) {\n                item.shape = srcItem.shape\n                item.shapeProps = fromJSON(srcItem.shapeProps)\n                item.textSlots = fromJSON(srcItem.textSlots)\n            }\n        }\n\n        item.args.set('templateIgnoredProps', List('name', 'shape', 'shapeProps.*'))\n        item.locked = false\n        if (node.id != rootNode.id) {\n            item.args.set('tplArea', 'controlled')\n        }\n        item.args.set('tplRotation', 'off')\n        item.args.set('tplConnector', 'off')\n\n        if (shape == 'none') {\n            item.setText('body', 'Add your text...')\n        }\n        item\n    })\n}\n\nfunc createNewChildFor(nodeId, placement) {\n    local node = rootNode.findById(nodeId)\n    if (node) {\n        local x = 0\n        local y = 0\n        local w = max(1, node.w)\n        local h = max(1, node.h)\n        local shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n\n\n        if (node.children.size > 0) {\n            local childNode = node.children.get(0)\n            if (childNode.data.has('s')) {\n                shape = if (childNode.data.has('s')) { childNode.data.get('s') } else { shape }\n            }\n\n            w = max(1, childNode.w)\n            h = max(1, childNode.h)\n        }\n\n        correctiveVector = Vector(0, h * 0.8)\n\n        if (placement == 'top') {\n            y = - padding - h\n            x = node.w / 2 - w / 2\n            correctiveVector = Vector(w * 0.6, 0)\n        } else if (placement == 'bottom') {\n            y = node.h + padding\n            x = node.w / 2 - w / 2\n            correctiveVector = Vector(w * 0.6, 0)\n        } else if (placement == 'left') {\n            x = - padding - w\n            y = node.h / 2 - h / 2\n        } else if (placement == 'right') {\n            x = node.w + padding\n            y = node.h / 2 - h / 2\n        }\n\n        local childAreas = node.children.map((childNode) => { Area(childNode.x, childNode.y, childNode.w, childNode.h) })\n\n        func overlapsChildren(area) {\n            local overlaps = false\n            for (local i = 0; !overlaps && i < childAreas.size; i++) {\n                overlaps = area.overlaps(childAreas.get(i))\n            }\n            overlaps\n        }\n\n        local overlaps = true\n        local tries = 0\n\n        local area\n\n        while(overlaps && tries < 1000) {\n            direction = if (tries % 2 == 0) { 1 } else { -1 }\n            displacement = correctiveVector * tries * direction\n            area = Area(x + displacement.x, y + displacement.y, w, h)\n            overlaps = overlapsChildren(area)\n            tries++\n        }\n\n        local childNode = TreeNode(uid(), Map('x', area.x, 'y', area.y, 'w', w, 'h', h, 's', shape, 'p', 0))\n        node.children.add(childNode)\n\n        updateProgress(rootNode)\n\n        encodeMindMap()\n    }\n}\n\nfunc shouldNodeShapeSelectorBeDisplayed(selectedItemIds) {\n    local shown = false\n    selectedItemIds.forEach((itemId) => {\n        if (rootNode.findById(itemId)) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc selectShapeForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        updateItem(itemId, (item) => {\n            item.shape = panelItem.shape\n            forEach(panelItem.shapeProps, (value, name) => {\n                if (name != 'fill') {\n                    setObjectField(item.shapeProps, name, value)\n                }\n            })\n            local node = rootNode.findById(itemId)\n            if (node) {\n                node.data.set('s', panelItem.shape)\n                encodeMindMap()\n            }\n\n            if (panelItem.shape == 'none') {\n                if (!item.textSlots.body) {\n                    setObjectField(item.textSlots, 'body', toJSON(Map('text', 'Add your text...')))\n                }\n                if (item.textSlots.body) {\n                    if (!item.textSlots.body.text || item.textSlots.body.text == '<p></p>') {\n                        setObjectField(item.textSlots.body, 'text', 'Ad your text...')\n                    }\n                }\n            }\n        })\n    })\n}\n\nfunc shouldNodeIconSelectorBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n}\n\n\nfunc selectIconForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        local node = rootNode.findById(itemId)\n        if (node) {\n            setNodeIcon(node, panelItem.id)\n        }\n    })\n}\n\nfunc shouldNodeProgressEditorBeDisplayed(selectedItemIds) {\n    if (showProgress) {\n        local showPanel = false\n        selectedItemIds.forEach((itemId) => {\n            local node = rootNode.findById(itemId)\n            if (node && node.children.size == 0) {\n                showPanel = true\n            }\n        })\n        showPanel\n    } else {\n        false\n    }\n}\n\nfunc getAllProgressIconItems() {\n    List(0, 25, 50, 75, 100).map((percent) => {\n        items = createProgressIconItems(`icon-${percent}`, percent, progressColor2, 0, 0)\n        Item(`progress_${percent}_container`, `${percent}`, 'none', 2, 2, progressSize, progressSize, Map(), items, Map(\n            'mindMapProgress', percent\n        )).toJSON()\n    })\n}\n\nfunc updateProgress(node) {\n    if (node.children.size > 0) {\n        local sumProgress = 0\n        node.children.forEach((childNode) => {\n            sumProgress += updateProgress(childNode)\n        })\n\n        local totalProgress = sumProgress / node.children.size\n        node.data.set('p', totalProgress)\n        totalProgress\n    } else {\n        if (node.data.has('p')) {\n            node.data.get('p')\n        } else {\n            0\n        }\n    }\n}\n\nfunc selectProgressForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        local node = rootNode.findById(itemId)\n        if (node && node.children.size == 0) {\n            node.data.set('p', panelItem.args.mindMapProgress)\n        }\n    })\n\n    updateProgress(rootNode)\n\n    encodeMindMap()\n}\n\n// triggered when item area changes as a result of edit box modifications\n// the handler is supposed to mutate the area object in case the area is changed\nfunc onAreaUpdate(itemId, item, area) {\n    local node = rootNode.findById(itemId)\n    if (node) {\n        node.data.set('x', area.x)\n        node.data.set('y', area.y)\n        node.data.set('w', area.w)\n        node.data.set('h', area.h)\n        encodeMindMap()\n    }\n}\n\n// Template special function. Triggered when user deletes templated item\nfunc onDeleteItem(itemId, item) {\n    local node\n    if (item.args.mindMapType == 'icon') {\n        node = rootNode.findById(item.args.mindMapNodeId)\n        if (node) {\n            removeNodeIcon(node, item.args.mindMapIcon)\n        }\n    } else if (item.args.mindMapType == 'node') {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            node.parent.children.remove(node.siblingIdx)\n            updateProgress(rootNode)\n            encodeMindMap()\n        }\n    }\n}\n\nfunc onCopyItem(itemId, item) {\n    local node = rootNode.findById(itemId)\n    if (node) {\n        encodedNode = node.encodeTree(' | ', ';')\n        setObjectField(item.args, 'mindMap_EncodedNode', encodedNode)\n    }\n}\n\nfunc onPasteItems(itemId, items) {\n    local dstNode = rootNode.findById(itemId)\n    if (dstNode) {\n        items.forEach((item) => {\n            if (item.args && item.args.mindMap_EncodedNode) {\n                newRootNode = decodeTree(item.args.mindMap_EncodedNode, ' | ', ';')\n\n                nodesById = Map()\n                newRootNode.traverse((node) => {\n                    nodesById.set(node.id, node)\n                    node.id = uid()\n                })\n\n                traverseItems = (item) => {\n                    if (item.args.templated && item.args.templatedId && nodesById.has(item.args.templatedId)) {\n                        node = nodesById.get(item.args.templatedId)\n                        node.tempData.set('sourceItem', item)\n                    }\n                    if (item.childItems) {\n                        item.childItems.forEach(traverseItems)\n                    }\n                }\n                traverseItems(item)\n                newRootNode.attachTo(dstNode)\n            }\n        })\n\n        reindexTree(rootNode)\n        updateProgress(rootNode)\n        rootItem = buildTemplateItems(rootNode)\n        rootItem.name = 'Mind map'\n        rootItem.w = width\n        rootItem.h = height\n\n        encodeMindMap()\n    }\n}\n\nfunc reindexTree(rootNode) {\n    rootNode.traverse((node, parent) => {\n        local x = parseInt(node.data.get('x'))\n        local y = parseInt(node.data.get('y'))\n        local w = parseInt(node.data.get('w'))\n        local h = parseInt(node.data.get('h'))\n        local p = 0\n        if (node.data.has('p')) {\n            p = parseInt(node.data.get('p'))\n        }\n\n        node.data.set('x', x)\n        node.data.set('y', y)\n        node.data.set('w', w)\n        node.data.set('h', h)\n        node.data.set('p', p)\n\n        node.x = x\n        node.y = y\n        local pos = updateAbsoluteNodePosition(node)\n\n        local addingControl = (location, placement, cx, cy) => {\n            Control(`add_child_${location}`, Map('nodeId', node.id), `createNewChildFor(control.data.nodeId, '${location}')`, cx, cy, 20, 20, '+', placement, node.id)\n        }\n\n        if (parent) {\n            node.w = w\n            node.h = h\n            local srcPinId = prepareConnectorForNode(node, parent)\n            if (srcPinId == 't') {\n                controls.add(addingControl('bottom', 'TL', pos.x + node.w / 2 - 10, pos.y + node.h + controlPadding))\n            } else if (srcPinId == 'b') {\n                controls.add(addingControl('top', 'BL', pos.x + node.w / 2 - 10, pos.y - controlPadding))\n            } else if (srcPinId == 'l') {\n                controls.add(addingControl('right', 'TL', pos.x + node.w + controlPadding, pos.y + node.h / 2 - 10))\n            } else if (srcPinId == 'r') {\n                controls.add(addingControl('left', 'TR', pos.x - controlPadding, pos.y + node.h / 2 - 10))\n            }\n        } else {\n            node.w = width\n            node.h = height\n\n            controls.extendList(List(\n                addingControl('top', 'BL', node.w / 2 - 10, -controlPadding),\n                addingControl('bottom', 'TL', node.w / 2 - 10, node.h + controlPadding),\n                addingControl('left', 'TR', -controlPadding, node.h / 2 - 10),\n                addingControl('right', 'TL', node.w + controlPadding, node.h / 2 - 10)\n            ))\n        }\n    })\n}\n\n\nfunc shouldNodeOperationsPanelBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n    local shown = false\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc onOperationsPanelClick(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node) {\n            if (panelItem.id == 'insert-new-parent' && node.parent) {\n                insertNewParentFor(node)\n            } else if (panelItem.id == 'delete-node-preserve-children' && node.parent) {\n                deleteNodePreservingChildren(node)\n            }\n        }\n    })\n}\n\nfunc insertNewParentFor(node) {\n    local oldParent = node.parent\n    local dx = node.x - node.parent.x\n    local dy = node.y - node.parent.y\n\n    local found = false\n    for (local i = 0; !found && i < node.parent.children.size; i++) {\n        local childNode = node.parent.children.get(i)\n        if (childNode.id == node.id) {\n            found = true\n            node.parent.children.remove(i)\n        }\n    }\n\n    local newParent = TreeNode(uid())\n    node.data.forEach((value, name) => { newParent.data.set(name, value) })\n    newParent.x = node.x\n    newParent.y = node.y\n    newParent.w = node.w\n    newParent.h = node.h\n\n    node.attachTo(newParent)\n    newParent.attachTo(oldParent)\n    updateProgress(rootNode)\n    encodeMindMap()\n}\n\nfunc deleteNodePreservingChildren(node) {\n    local found = false\n    local parent = node.parent\n    for (local i = 0; !found && i < parent.children.size; i++) {\n        if (node.id == parent.children.get(i).id) {\n            parent.children.remove(i)\n            local oldSize = parent.children.size - 1\n            parent.children.extendList(node.children)\n            node.children.forEach((childNode, idx) => {\n                childNode.parent = parent\n                childNode.siblingIdx = oldSize + idx\n            })\n        }\n    }\n\n    updateProgress(rootNode)\n    encodeMindMap()\n}\n\nrootNode = decodeTree(nodes, ' | ', ';')\nreindexTree(rootNode)\n\n if (context.phase == 'build') {\n    rootItem = buildTemplateItems(rootNode)\n    rootItem.name = 'Mind map'\n    rootItem.w = width\n    rootItem.h = height\n}\n\n\n"}