{"name": "Mind map", "description": "", "args": {"nodes": {"type": "string", "value": "root:x=0:y=0|1:x=100:y=-100:w=200:h=100|2:x=100:y=100:w=200:h=100", "name": "Nodes encoded", "hidden": true}}, "preview": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhodG1sPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmlld0JveD0iLTEwIC0xMCAzNDAgMjIwIj48ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMCwwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJaZ2txU09HSVkiIGRhdGEtaXRlbS1pZD0iWmdrcVNPR0lZIj4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPiA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiPjxnPjxnPjxnPiA8L2c+IDxwYXRoIGQ9Ik0gMTAwIDYwICBMIDIwIDYwIGEgMjAgMjAgMCAwIDEgLTIwIC0yMCAgTCAwIDIwICBhIDIwIDIwIDAgMCAxIDIwIC0yMCAgIEwgMTAwIDAgICBhIDIwIDIwIDAgMCAxIDIwIDIwICBMIDEyMCA0MCAgIGEgMjAgMjAgMCAwIDEgLTIwIDIwIFoiIHN0cm9rZS13aWR0aD0iMnB4IiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWRhc2hhcnJheT0iIiBzdHJva2UtZGFzaG9mZnNldD0iMCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1aZ2txU09HSVkiLz4gICAgICAgPC9nPjwvZz4KPGcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDE0MCkgcm90YXRlKDApIiBkYXRhLXN2Zy1pdGVtLWNvbnRhaW5lci1pZD0iaDdSV0p0UTBLIiBkYXRhLWl0ZW0taWQ9Img3UldKdFEwSyI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9InJnYmEoMjQwLDI0MCwyNDAsMS4wKSIvPjwvZz48L2c+PC9nPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ii8+PC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItaDdSV0p0UTBLIi8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjAsNjApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9ImRwUXQ3Tlk4dyIgZGF0YS1pdGVtLWlkPSJkcFF0N05ZOHciPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+PGcgbW9kZT0iZWRpdCIgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCAwIEMgMTAwIDM4Ljg3IDAgIDIxLjEzIDAgNjAgIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2UtbGluZWpvaW46IHJvdW5kOyIvPiA8Zz48cGF0aCBkPSJNIC01IDYwIEwgMCA4MCBMIDUgNjAgIHogIiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PC9nPiAgIDwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLWRwUXQ3Tlk4dyIvPiAgICAgICA8L2c+PC9nPgo8ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwxNDApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9Ik1Nanh4QXptVzQiIGRhdGEtaXRlbS1pZD0iTU1qeHhBem1XNCI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1NTWp4eEF6bVc0Ii8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTYwLDYwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJSSkhNU2FYUTYiIGRhdGEtaXRlbS1pZD0iUkpITVNhWFE2Ij4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPjxnIG1vZGU9ImVkaXQiIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGc+IDwvZz4gPHBhdGggZD0iTSAwIDAgQyAwIDM4Ljg3IDEwMCAgMjEuMTMgMTAwIDYwICIgc3Ryb2tlLXdpZHRoPSIycHgiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiLz4gPGc+PHBhdGggZD0iTSA5NSA2MCBMIDEwMCA4MCBMIDEwNSA2MCAgeiAiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L2c+ICAgPC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItUkpITVNhWFE2Ii8+ICAgICAgIDwvZz48L2c+PC9zdmc+", "defaultArea": {"x": 0, "y": 0, "w": 120, "h": 60}, "import": ["./src/treenode.sch", "./src/item.sch", "./src/control.sch", "./src/mind-map.sch"], "controls": [{"$-foreach": {"source": "controls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "item": {"$-recurse": {"object": {"$-expr": "rootItem"}, "it": "it", "children": "it.childItems", "dstChildren": "childItems"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "`${it.name} x: ${it.x}, y: ${it.y}`"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "it.getArgs()"}, "locked": {"$-expr": "it.locked"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, "init": "struct TreeNode {\n    id: uid()\n    data: Map()\n    parent: null\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n    siblingIdx: 0\n    level: 0\n    children: List()\n    tempData: Map()\n\n    findById(nodeId) {\n        if (this.id == nodeId) {\n            this\n        } else {\n            foundNode = null\n            for (i = 0; i < this.children.size && !foundNode; i++) {\n                foundNode = this.children.get(i).findById(nodeId)\n            }\n            foundNode\n        }\n    }\n\n    map(callback) {\n        mappedChildren = List()\n        this.children.forEach((childNode) => {\n            mappedChildren.add(childNode.map(callback))\n        })\n        callback(this, mappedChildren)\n    }\n\n    attachTo(parentNode) {\n        this.parent = parentNode\n        this.siblingIdx = parentNode.children.size\n        parentNode.children.add(this)\n    }\n\n    attachChildAtIndex(childNode, idx) {\n        childNode.parent = this\n        this.children.insert(idx, childNode)\n        this.children.forEach((node, nodeIdx) => {\n            node.siblingIdx = nodeIdx\n        })\n    }\n\n    encodeTree(nodeSeparator, paramSeparator) {\n        encoded = this.id\n        this.data.forEach((value, name) => {\n            encoded = encoded + paramSeparator + name + '=' + value\n        })\n        this.children.forEach((childNode) => {\n            childEncoded = childNode.encodeTree(nodeSeparator, paramSeparator)\n            encoded += nodeSeparator + childEncoded\n        })\n        encoded + nodeSeparator + 'N'\n    }\n\n    reindex(callback) {\n        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }\n        if (this.children.size > 0) {\n            this.children.forEach((childNode) => {\n                childNode.reindex(callback)\n            })\n        }\n        if (callback) {\n            callback(this)\n        }\n    }\n\n    traverse(callback) {\n        callback(this, this.parent)\n        this.children.forEach((childNode) => {\n            childNode.traverse(callback)\n        })\n    }\n}\n\ndecodeTreeNode = (nodeEncoded, paramSeparator) => {\n    nodeParts = splitString(nodeEncoded, paramSeparator)\n    nodeId = nodeParts.shift()\n    nodeData = Map()\n    nodeParts.forEach((encodedParameter) => {\n        paramParts = splitString(encodedParameter, '=')\n        if (paramParts.size == 2) {\n            nodeData.set(paramParts.get(0), paramParts.get(1))\n        }\n    })\n\n    TreeNode(nodeId, nodeData)\n}\n\ndecodeTree = (encodedText, nodeSeparator, paramSeparator) => {\n    nodeList = splitString(encodedText, nodeSeparator)\n    rootNode = decodeTreeNode(nodeList.shift(), paramSeparator)\n    currentNode = rootNode\n    while(nodeList.size > 0) {\n        nodeEncoded = nodeList.shift()\n        if (nodeEncoded == 'N') {\n            parent = currentNode.parent\n            if (!parent) {\n                parent = rootNode\n            }\n            currentNode = parent\n        } else {\n            newNode = decodeTreeNode(nodeEncoded, paramSeparator)\n            newNode.attachTo(currentNode)\n            currentNode = newNode\n        }\n    }\n    rootNode\n}\n\n\n\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n}\n\npadding = 60\ncontrolPadding = 40\ncontrols = List()\n\nstruct PinPoint {\n    id: 't'\n    x: 0\n    y: 0\n    normal: Vector(0, -1)\n}\n\n\nfunc findPinPointForNode(node, offset, p2) {\n    p1 = Vector(node.w/2, node.h/2) + offset\n    v = (p2 - p1).normalized()\n\n    k = node.w/node.h\n\n    warpedV = Vector(v.x, v.y * k)\n\n    allPins = List(\n        PinPoint('t', node.w/2, 0,        Vector(0, -1)),\n        PinPoint('b', node.w/2, node.h,   Vector(0, 1)),\n        PinPoint('l', 0,        node.h/2, Vector(-1, 0)),\n        PinPoint('r', node.w,   node.h/2, Vector(1, 0))\n    )\n\n    closestPin = allPins.get(0)\n    closestDistance = -1000\n\n    pv = p1 + warpedV * 10\n\n    allPins.forEach((pin) => {\n        warpedPin = p1 + node.w * pin.normal\n        delta = warpedPin - pv\n        dSquared = delta * delta\n\n        if (closestDistance < 0 || closestDistance > dSquared) {\n            closestDistance = dSquared\n            closestPin = pin\n        }\n    })\n\n    closestPin\n}\n\nrootNode = decodeTree(nodes, '|', ':')\n\nfunc encodeMindMap() {\n    nodes = rootNode.encodeTree('|', ':')\n}\n\nfunc prepareConnectorForNode(node, parent) {\n    connector = Item(`connector-${parent.id}-${node.id}`, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n\n    x1 = parent.w/2\n    y1 = parent.h/2\n\n    x2 = node.x + node.w/2\n    y2 = node.y + node.h/2\n\n    childOffset = Vector(node.x, node.y)\n\n    pin1 = findPinPointForNode(parent, Vector(0, 0), Vector(x2, y2))\n    pin2 = findPinPointForNode(node, childOffset, Vector(x1, y2))\n\n    connector.shapeProps.set('points', List(\n        Map('id', pin1.id, 'x', pin1.x, 'y', pin1.y, 'nx', pin1.normal.x, 'ny', pin1.normal.y),\n        Map('id', pin2.id, 'x', pin2.x + childOffset.x, 'y', pin2.y + childOffset.y, 'nx', pin2.normal.x, 'ny', pin2.normal.y)\n    ))\n\n    connector.shapeProps.set('sourceItem', `#${parent.id}`)\n    connector.shapeProps.set('sourcePin', pin1.id)\n    connector.shapeProps.set('destinationItem', `#${node.id}`)\n    connector.shapeProps.set('destinationPin', pin2.id)\n\n    if (parent.tempData.has('connectors')) {\n        parent.tempData.get('connectors').add(connector)\n    } else {\n        parent.tempData.set('connectors', List(connector))\n    }\n\n    pin2.id\n}\n\nABS_POS = 'absolutePosition'\n\nfunc updateAbsoluteNodePosition(node) {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    localPos = Vector(x, y)\n\n    pos = (if (node.parent) {\n        if (node.parent.tempData.has(ABS_POS)) {\n            node.parent.tempData.get(ABS_POS) + localPos\n        } else {\n            parentPos = updateAbsoluteNodePosition(node.parent)\n            parentPos + localPos\n        }\n    } else {\n        localPos\n    })\n\n    node.tempData.set(ABS_POS, pos)\n\n    pos\n}\n\nrootNode.traverse((node, parent) => {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    w = parseInt(node.data.get('w'))\n    h = parseInt(node.data.get('h'))\n    node.data.set('x', x)\n    node.data.set('y', y)\n    node.data.set('w', w)\n    node.data.set('h', h)\n\n    pos = updateAbsoluteNodePosition(node)\n\n    parentX = if (parent) { parent.x } else { 0 }\n    parentY = if (parent) { parent.y } else { 0 }\n    node.x = x + parentX\n    node.y = y + parentY\n\n    addingControl = (location, placement, cx, cy) => {\n        Control(`add_child_${location}`, Map('nodeId', node.id), `createNewChildFor(control.data.nodeId, '${location}')`, cx, cy, 20, 20, '+', placement, node.id)\n    }\n\n    if (parent) {\n        node.w = w\n        node.h = h\n        pinId = prepareConnectorForNode(node, parent)\n        controls.extendList(List(\n            addingControl('top', 'BL', pos.x + node.w / 2 - 10, pos.y - controlPadding),\n            addingControl('bottom', 'TL', pos.x + node.w / 2 - 10, pos.y + node.h + controlPadding),\n            addingControl('left', 'TR', pos.x - controlPadding, pos.y + node.h / 2 - 10),\n            addingControl('right', 'TL', pos.x + node.w + controlPadding, pos.y + node.h / 2 - 10)\n        ).filter((control) => {!control.name.startsWith(`add_child_${pinId}`)}))\n    } else {\n        node.w = width\n        node.h = height\n\n        controls.extendList(List(\n            addingControl('top', 'BL', node.w / 2 - 10, -controlPadding),\n            addingControl('bottom', 'TL', node.w / 2 - 10, node.h + controlPadding),\n            addingControl('left', 'TR', -controlPadding, node.h / 2 - 10),\n            addingControl('right', 'TL', node.w + controlPadding, node.h / 2 - 10)\n        ))\n    }\n})\n\n\nrootItem = rootNode.map((node, childItems) => {\n    x = node.data.get('x')\n    y = node.data.get('y')\n    w = node.data.get('w')\n    h = node.data.get('h')\n\n    if (node.tempData.has('connectors')) {\n        childItems.extendList(node.tempData.get('connectors'))\n    }\n\n    item = Item(node.id, `item ${node.id}`, 'rect', x, y, w, h, Map(), childItems)\n    item.args.set('templateIgnoredProps', List('shapeProps.fill', 'shapeProps.strokeColor', 'shapeProps.strokeSize', 'shapeProps.strokePattern'))\n    item.locked = false\n    if (node.id != rootNode.id) {\n        item.args.set('tplArea', 'controlled')\n    }\n    item.args.set('tplRotation', 'off')\n    item.args.set('tplConnector', 'off')\n    item\n})\n\nrootItem.name = 'Mind map'\nrootItem.w = width\nrootItem.h = height\n\n\nfunc createNewChildFor(nodeId, placement) {\n    node = rootNode.findById(nodeId)\n    if (node) {\n        x = 0\n        y = 0\n        w = 160\n        h = 30\n\n        if (placement == 'top') {\n            y = - padding - h\n            x = node.w / 2 - w / 2\n        } else if (placement == 'bottom') {\n            y = node.h + padding\n            x = node.w / 2 - w / 2\n        } else if (placement == 'left') {\n            x = - padding - w\n            y = node.h / 2 - h / 2\n        } else if (placement == 'right') {\n            x = node.w + padding\n            y = node.h / 2 - h / 2\n        }\n\n        childNode = TreeNode(uid(), Map('x', x, 'y', y, 'w', w, 'h', h))\n        node.children.add(childNode)\n\n        encodeMindMap()\n    }\n}\n\n// triggered when item area changes as a result of edit box modifications\n// the handler is supposed to mutate the area object in case the area is changed\non('area', (itemId, item, area) => {\n    node = rootNode.findById(itemId)\n    if (node) {\n        node.data.set('x', area.x)\n        node.data.set('y', area.y)\n        encodeMindMap()\n    }\n})\n\non('delete', (itemId, item) => {\n    node = rootNode.findById(itemId)\n    if (node && node.parent) {\n        node.parent.children.remove(node.siblingIdx)\n        encodeMindMap()\n    }\n})\n\n"}