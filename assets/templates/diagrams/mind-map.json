{"name": "Mind map", "description": "", "args": {"nodes": {"type": "string", "value": "root;x=0;y=0;s=uml_start", "name": "Nodes encoded", "hidden": true}, "connectorType": {"type": "choice", "value": "smooth", "options": ["linear", "smooth", "step", "step-cut", "step-smooth"], "name": "Connectors Type"}, "capType": {"type": "path-cap", "value": "triangle", "name": "Cap type"}, "capSize": {"type": "number", "value": 15, "name": "Cap size"}}, "preview": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhodG1sPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmlld0JveD0iLTEwIC0xMCAzNDAgMjIwIj48ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMCwwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJaZ2txU09HSVkiIGRhdGEtaXRlbS1pZD0iWmdrcVNPR0lZIj4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPiA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiPjxnPjxnPjxnPiA8L2c+IDxwYXRoIGQ9Ik0gMTAwIDYwICBMIDIwIDYwIGEgMjAgMjAgMCAwIDEgLTIwIC0yMCAgTCAwIDIwICBhIDIwIDIwIDAgMCAxIDIwIC0yMCAgIEwgMTAwIDAgICBhIDIwIDIwIDAgMCAxIDIwIDIwICBMIDEyMCA0MCAgIGEgMjAgMjAgMCAwIDEgLTIwIDIwIFoiIHN0cm9rZS13aWR0aD0iMnB4IiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWRhc2hhcnJheT0iIiBzdHJva2UtZGFzaG9mZnNldD0iMCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1aZ2txU09HSVkiLz4gICAgICAgPC9nPjwvZz4KPGcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDE0MCkgcm90YXRlKDApIiBkYXRhLXN2Zy1pdGVtLWNvbnRhaW5lci1pZD0iaDdSV0p0UTBLIiBkYXRhLWl0ZW0taWQ9Img3UldKdFEwSyI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9InJnYmEoMjQwLDI0MCwyNDAsMS4wKSIvPjwvZz48L2c+PC9nPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ii8+PC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItaDdSV0p0UTBLIi8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjAsNjApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9ImRwUXQ3Tlk4dyIgZGF0YS1pdGVtLWlkPSJkcFF0N05ZOHciPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+PGcgbW9kZT0iZWRpdCIgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCAwIEMgMTAwIDM4Ljg3IDAgIDIxLjEzIDAgNjAgIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2UtbGluZWpvaW46IHJvdW5kOyIvPiA8Zz48cGF0aCBkPSJNIC01IDYwIEwgMCA4MCBMIDUgNjAgIHogIiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PC9nPiAgIDwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLWRwUXQ3Tlk4dyIvPiAgICAgICA8L2c+PC9nPgo8ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwxNDApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9Ik1Nanh4QXptVzQiIGRhdGEtaXRlbS1pZD0iTU1qeHhBem1XNCI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1NTWp4eEF6bVc0Ii8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTYwLDYwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJSSkhNU2FYUTYiIGRhdGEtaXRlbS1pZD0iUkpITVNhWFE2Ij4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPjxnIG1vZGU9ImVkaXQiIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGc+IDwvZz4gPHBhdGggZD0iTSAwIDAgQyAwIDM4Ljg3IDEwMCAgMjEuMTMgMTAwIDYwICIgc3Ryb2tlLXdpZHRoPSIycHgiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiLz4gPGc+PHBhdGggZD0iTSA5NSA2MCBMIDEwMCA4MCBMIDEwNSA2MCAgeiAiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L2c+ICAgPC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItUkpITVNhWFE2Ii8+ICAgICAgIDwvZz48L2c+PC9zdmc+", "defaultArea": {"x": 0, "y": 0, "w": 120, "h": 60}, "import": ["./src/treenode.sch", "./src/item.sch", "./src/control.sch", "./src/mind-map.sch"], "controls": [{"$-foreach": {"source": "controls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "editor": {"panels": [{"id": "node-icon-selector", "condition": "shouldNodeIconSelectorBeDisplayed(selectedItemIds)", "type": "slot-menu", "click": "selectIconForItems(selectedItemIds, panelItem)", "name": "Choose icons", "slotSize": {"width": 24, "height": 24}, "items": [{"$-foreach": {"source": "getAllAvailableIcons()", "it": "icon"}, "id": {"$-expr": "icon.id"}, "shape": "image", "area": {"x": -2, "y": -2, "w": 18, "h": 18}, "shapeProps": {"image": {"$-expr": "icon.url"}}}]}, {"id": "node-shape-selector", "condition": "shouldNodeShapeSelectorBeDisplayed(selectedItemIds)", "type": "slot-menu", "click": "selectShapeForItems(selectedItemIds, panelItem)", "name": "Select shape", "slotSize": {"width": 80, "height": 40}, "items": [{"id": "rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 0, "fill": {"type": "none"}}}, {"id": "rounded-rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 10, "fill": {"type": "none"}}}, {"id": "start", "shape": "uml_start", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "ellipse", "shape": "ellipse", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 5, "fill": {"type": "none"}}}, {"id": "label", "shape": "none", "area": {"w": 72, "h": 32}, "textSlots": {"body": {"text": "Simple label"}}}]}]}, "item": {"$-recurse": {"object": {"$-expr": "rootItem"}, "it": "it", "children": "it.childItems", "dstChildren": "childItems"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "`${it.name}`"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "it.getArgs()"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, "init": "struct TreeNode {\n    id: uid()\n    data: Map()\n    parent: null\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n    siblingIdx: 0\n    level: 0\n    children: List()\n    tempData: Map()\n\n    findById(nodeId) {\n        if (this.id == nodeId) {\n            this\n        } else {\n            foundNode = null\n            for (i = 0; i < this.children.size && !foundNode; i++) {\n                foundNode = this.children.get(i).findById(nodeId)\n            }\n            foundNode\n        }\n    }\n\n    map(callback) {\n        mappedChildren = List()\n        this.children.forEach((childNode) => {\n            mappedChildren.add(childNode.map(callback))\n        })\n        callback(this, mappedChildren)\n    }\n\n    attachTo(parentNode) {\n        this.parent = parentNode\n        this.siblingIdx = parentNode.children.size\n        parentNode.children.add(this)\n    }\n\n    attachChildAtIndex(childNode, idx) {\n        childNode.parent = this\n        this.children.insert(idx, childNode)\n        this.children.forEach((node, nodeIdx) => {\n            node.siblingIdx = nodeIdx\n        })\n    }\n\n    encodeTree(nodeSeparator, paramSeparator) {\n        encoded = this.id\n        this.data.forEach((value, name) => {\n            encoded = encoded + paramSeparator + name + '=' + value\n        })\n        this.children.forEach((childNode) => {\n            childEncoded = childNode.encodeTree(nodeSeparator, paramSeparator)\n            encoded += nodeSeparator + childEncoded\n        })\n        encoded + nodeSeparator + 'N'\n    }\n\n    reindex(callback) {\n        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }\n        if (this.children.size > 0) {\n            this.children.forEach((childNode) => {\n                childNode.reindex(callback)\n            })\n        }\n        if (callback) {\n            callback(this)\n        }\n    }\n\n    traverse(callback) {\n        callback(this, this.parent)\n        this.children.forEach((childNode) => {\n            childNode.traverse(callback)\n        })\n    }\n}\n\ndecodeTreeNode = (nodeEncoded, paramSeparator) => {\n    nodeParts = splitString(nodeEncoded, paramSeparator)\n    nodeId = nodeParts.shift()\n    nodeData = Map()\n    nodeParts.forEach((encodedParameter) => {\n        paramParts = splitString(encodedParameter, '=')\n        if (paramParts.size == 2) {\n            nodeData.set(paramParts.get(0), paramParts.get(1))\n        }\n    })\n\n    TreeNode(nodeId, nodeData)\n}\n\ndecodeTree = (encodedText, nodeSeparator, paramSeparator) => {\n    nodeList = splitString(encodedText, nodeSeparator)\n    rootNode = decodeTreeNode(nodeList.shift(), paramSeparator)\n    currentNode = rootNode\n    while(nodeList.size > 0) {\n        nodeEncoded = nodeList.shift()\n        if (nodeEncoded == 'N') {\n            parent = currentNode.parent\n            if (!parent) {\n                parent = rootNode\n            }\n            currentNode = parent\n        } else {\n            newNode = decodeTreeNode(nodeEncoded, paramSeparator)\n            newNode.attachTo(currentNode)\n            currentNode = newNode\n        }\n    }\n    rootNode\n}\n\n\n\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n    textSlots: Map()\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n\n    setText(slotName, text) {\n        if (!this.textSlots.has(slotName)) {\n            this.textSlots.set(slotName, Map('text', text))\n        } else {\n            this.textSlots.get(slotName).set('text', text)\n        }\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n}\n\npadding = 60\ncontrolPadding = 40\ncontrols = List()\n\nallIcons = Map(\n    'search', '/assets/art/google-cloud/bigquery/bigquery.svg',\n    'time', '/assets/art/azure/General/10006-icon-service-Recent.svg',\n    'cloud', '/assets/art/google-cloud/my_cloud/my_cloud.svg',\n    'heart', '/assets/art/azure/General/10811-icon-service-Heart.svg'\n)\n\n\nfunc getAllAvailableIcons() {\n    icons = List()\n\n    allIcons.forEach((url, id) => {\n        icons.add(toJSON(Map('id', id, 'url', url)))\n    })\n    icons\n}\n\nfunc getNodeIcons(node) {\n    icons = List()\n    if (node.data.has('icons')) {\n        iconSet = Set()\n        splitString(node.data.get('icons'), ',').forEach((iconId) => {\n            if (!iconSet.has(iconId)) {\n                icons.add(iconId)\n                iconSet.add(iconId)\n            }\n        })\n    }\n    icons\n}\n\nfunc encodeIcons(icons) {\n    encoded = ''\n    icons.forEach((id, idx) => {\n        if (idx > 0) {\n            encoded += ','\n        }\n        encoded += id\n    })\n    encoded\n}\n\n\nfunc setNodeIcon(node, iconId) {\n    icons = getNodeIcons(node)\n\n    idx = icons.findIndex((id) => { id == iconId })\n    if (idx < 0) {\n        icons.add(iconId)\n    } else {\n        icons.remove(idx)\n    }\n\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nfunc removeNodeIcon(node, iconId) {\n    icons = getNodeIcons(node)\n    idx = icons.findIndex((id) => { id == iconId })\n\n    if (idx >= 0) {\n        icons.remove(idx)\n    }\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nstruct PinPoint {\n    id: 't'\n    x: 0\n    y: 0\n    normal: Vector(0, -1)\n}\n\n// zone points should be arranged in a counter clock wise polygon\nfunc isPointInsideZone(testPoint, zonePoints) {\n    if (zonePoints.size < 3) {\n        false\n    } else {\n        lines = List()\n\n        for (i = 0; i < zonePoints.size - 1; i++) {\n            p1 = zonePoints.get(i)\n            p2 = zonePoints.get(i+1)\n            lines.add(Math.createLineEquation(p2.x, p2.y, p1.x, p1.y))\n        }\n\n        isInZone = true\n        for (i = 0; i < lines.size && isInZone; i++) {\n            if (Math.sideAgainstLine(testPoint.x, testPoint.y, lines.get(i)) < 0) {\n                isInZone = false\n            }\n        }\n        isInZone\n    }\n}\n\n\nfunc getPinPointById(pinId, node) {\n    if (pinId == 't') {\n        PinPoint('t', node.w/2, 0,        Vector(0, -1))\n    } else if (pinId == 'b') {\n        PinPoint('b', node.w/2, node.h,   Vector(0, 1))\n    } else if (pinId == 'l') {\n        PinPoint('l', 0,        node.h/2, Vector(-1, 0))\n    } else if (pinId == 'r') {\n        PinPoint('r', node.w,   node.h/2, Vector(1, 0))\n    }\n}\n\nrootNode = decodeTree(nodes, ' | ', ';')\n\nfunc encodeMindMap() {\n    nodes = rootNode.encodeTree(' | ', ';')\n}\n\nstruct SuggestedConnection {\n    srcPin: null\n    dstPin: null\n    zonePoints: List()\n}\n\nfunc findPinsForNodes(node, child) {\n\n    p1 = Vector(0, 0)\n    p2 = Vector(node.w, 0)\n    p3 = Vector(node.w, node.h)\n    p4 = Vector(0, node.h)\n\n    topRightV    = Vector(1, -3)\n    bottomLeftV  = -topRightV\n    topLeftV     = Vector(-1, -3)\n    bottomRightV = -topLeftV\n\n    srcTopPin    = getPinPointById('t', node)\n    srcBottomPin = getPinPointById('b', node)\n    srcLeftPin   = getPinPointById('l', node)\n    srcRightPin  = getPinPointById('r', node)\n\n    dstTopPin    = getPinPointById('t', child)\n    dstBottomPin = getPinPointById('b', child)\n    dstLeftPin   = getPinPointById('l', child)\n    dstRightPin  = getPinPointById('r', child)\n\n    childOffset = Vector(child.x, child.y)\n\n    t = Vector(node.w/2, 0)\n    t2 = t + Vector(0, -10)\n    b = Vector(node.w/2, node.h)\n    b2 = b + Vector(0, 10)\n\n    connections = List(\n        () => { SuggestedConnection(srcTopPin, dstRightPin, List(p1 + topLeftV, p1, t, t2)) },\n        () => { SuggestedConnection(srcTopPin, dstLeftPin, List(t2, t, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstLeftPin, List(p3 + bottomRightV, p3, b, b2)) },\n        () => { SuggestedConnection(srcBottomPin, dstRightPin, List(b2, b, p4, p4 + bottomLeftV)) },\n\n        () => { SuggestedConnection(srcRightPin, dstLeftPin, List(p2 + topRightV, p2, p3, p3 + bottomRightV)) },\n        () => { SuggestedConnection(srcLeftPin, dstRightPin, List(p4 + bottomLeftV, p4, p1, p1 + topLeftV)) },\n        () => { SuggestedConnection(srcTopPin, dstBottomPin, List(p1 + topLeftV, p1, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstTopPin, List(p3 + bottomRightV, p3, p4, p4 + bottomLeftV)) },\n    )\n\n    srcPin = srcRightPin\n    dstPin = dstLeftPin\n    matches = false\n\n    for (i = 0; i < connections.size && !matches; i++) {\n        connection = connections.get(i)()\n        srcPin = connection.srcPin\n        dstPin = connection.dstPin\n\n        testPoint = Vector(dstPin.x, dstPin.y) + childOffset\n        matches = isPointInsideZone(testPoint, connection.zonePoints)\n    }\n\n    List(srcPin, dstPin)\n}\n\nfunc prepareConnectorForNode(node, parent) {\n    connector = Item(`connector-${parent.id}-${node.id}`, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n\n    x1 = parent.w/2\n    y1 = parent.h/2\n\n    x2 = node.x + node.w/2\n    y2 = node.y + node.h/2\n\n    childOffset = Vector(node.x, node.y)\n\n    pins = findPinsForNodes(parent, node)\n    pin1 = pins.get(0)\n    pin2 = pins.get(1)\n\n    connector.shapeProps.set('points', List(\n        Map('id', pin1.id, 'x', pin1.x, 'y', pin1.y, 'nx', pin1.normal.x, 'ny', pin1.normal.y),\n        Map('id', pin2.id, 'x', pin2.x + childOffset.x, 'y', pin2.y + childOffset.y, 'nx', pin2.normal.x, 'ny', pin2.normal.y)\n    ))\n\n    connector.shapeProps.set('sourceItem', `#${parent.id}`)\n    connector.shapeProps.set('sourcePin', pin1.id)\n    connector.shapeProps.set('destinationItem', `#${node.id}`)\n    connector.shapeProps.set('destinationPin', pin2.id)\n    connector.shapeProps.set('sourceCap', 'empty')\n    connector.shapeProps.set('destinationCap', capType)\n    connector.shapeProps.set('destinationCapSize', capSize)\n    connector.shapeProps.set('smoothing', connectorType)\n\n    if (parent.tempData.has('connectors')) {\n        parent.tempData.get('connectors').add(connector)\n    } else {\n        parent.tempData.set('connectors', List(connector))\n    }\n\n    pin2.id\n}\n\nABS_POS = 'absolutePosition'\n\nfunc updateAbsoluteNodePosition(node) {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    localPos = Vector(x, y)\n\n    pos = (if (node.parent) {\n        if (node.parent.tempData.has(ABS_POS)) {\n            node.parent.tempData.get(ABS_POS) + localPos\n        } else {\n            parentPos = updateAbsoluteNodePosition(node.parent)\n            parentPos + localPos\n        }\n    } else {\n        localPos\n    })\n\n    node.tempData.set(ABS_POS, pos)\n\n    pos\n}\n\n\nrootNode.traverse((node, parent) => {\n    x = parseInt(node.data.get('x'))\n    y = parseInt(node.data.get('y'))\n    w = parseInt(node.data.get('w'))\n    h = parseInt(node.data.get('h'))\n    node.data.set('x', x)\n    node.data.set('y', y)\n    node.data.set('w', w)\n    node.data.set('h', h)\n\n    node.x = x\n    node.y = y\n    pos = updateAbsoluteNodePosition(node)\n\n    addingControl = (location, placement, cx, cy) => {\n        Control(`add_child_${location}`, Map('nodeId', node.id), `createNewChildFor(control.data.nodeId, '${location}')`, cx, cy, 20, 20, '+', placement, node.id)\n    }\n\n    if (parent) {\n        node.w = w\n        node.h = h\n        pinId = prepareConnectorForNode(node, parent)\n        controls.extendList(List(\n            addingControl('top', 'BL', pos.x + node.w / 2 - 10, pos.y - controlPadding),\n            addingControl('bottom', 'TL', pos.x + node.w / 2 - 10, pos.y + node.h + controlPadding),\n            addingControl('left', 'TR', pos.x - controlPadding, pos.y + node.h / 2 - 10),\n            addingControl('right', 'TL', pos.x + node.w + controlPadding, pos.y + node.h / 2 - 10)\n        ).filter((control) => {!control.name.startsWith(`add_child_${pinId}`)}))\n    } else {\n        node.w = width\n        node.h = height\n\n        controls.extendList(List(\n            addingControl('top', 'BL', node.w / 2 - 10, -controlPadding),\n            addingControl('bottom', 'TL', node.w / 2 - 10, node.h + controlPadding),\n            addingControl('left', 'TR', -controlPadding, node.h / 2 - 10),\n            addingControl('right', 'TL', node.w + controlPadding, node.h / 2 - 10)\n        ))\n    }\n})\n\n\nfunc createNodeIconItems(node) {\n    items = List()\n\n    w = 20\n    h = 20\n    margin = 5\n    getNodeIcons(node).forEach((iconId, idx) => {\n        x = (w + margin) * idx + 10\n        y = 10\n        items.add(Item(\n            `${node.id}_icon_${iconId}`, iconId, 'image', x, y, w, h, Map('image', allIcons.get(iconId)), List(), Map(\n                'mindMapType', 'icon',\n                'mindMapIcon', iconId,\n                'mindMapNodeId', node.id,\n            )\n        ))\n    })\n\n    items\n}\n\nrootItem = rootNode.map((node, childItems) => {\n    x = node.data.get('x')\n    y = node.data.get('y')\n    w = node.data.get('w')\n    h = node.data.get('h')\n\n    childItems.extendList(createNodeIconItems(node))\n\n    if (node.tempData.has('connectors')) {\n        childItems.extendList(node.tempData.get('connectors'))\n    }\n\n    shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n    item = Item(node.id, `item ${node.id}`, shape, x, y, w, h, Map(), childItems, Map(\n        'mindMapType', 'node'\n    ))\n    item.args.set('templateIgnoredProps', List('name', 'shape', 'shapeProps.*'))\n    item.locked = false\n    if (node.id != rootNode.id) {\n        item.args.set('tplArea', 'controlled')\n    }\n    item.args.set('tplRotation', 'off')\n    item.args.set('tplConnector', 'off')\n\n    if (shape == 'none') {\n        item.setText('body', 'Add your text...')\n    }\n    item\n})\n\nrootItem.name = 'Mind map'\nrootItem.w = width\nrootItem.h = height\n\n\nfunc createNewChildFor(nodeId, placement) {\n    node = rootNode.findById(nodeId)\n    if (node) {\n        x = 0\n        y = 0\n        w = max(1, node.w)\n        h = max(1, node.h)\n        shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n        if (placement == 'top') {\n            y = - padding - h\n            x = node.w / 2 - w / 2\n        } else if (placement == 'bottom') {\n            y = node.h + padding\n            x = node.w / 2 - w / 2\n        } else if (placement == 'left') {\n            x = - padding - w\n            y = node.h / 2 - h / 2\n        } else if (placement == 'right') {\n            x = node.w + padding\n            y = node.h / 2 - h / 2\n        }\n\n        childNode = TreeNode(uid(), Map('x', x, 'y', y, 'w', w, 'h', h, 's', shape))\n        node.children.add(childNode)\n\n        encodeMindMap()\n    }\n}\n\n// triggered when item area changes as a result of edit box modifications\n// the handler is supposed to mutate the area object in case the area is changed\non('area', (itemId, item, area) => {\n    node = rootNode.findById(itemId)\n    if (node) {\n        node.data.set('x', area.x)\n        node.data.set('y', area.y)\n        node.data.set('w', area.w)\n        node.data.set('h', area.h)\n        encodeMindMap()\n    }\n})\n\non('delete', (itemId, item) => {\n    if (item.args.mindMapType == 'icon') {\n        node = rootNode.findById(item.args.mindMapNodeId)\n        if (node) {\n            removeNodeIcon(node, item.args.mindMapIcon)\n        }\n    } else if (item.args.mindMapType == 'node') {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            node.parent.children.remove(node.siblingIdx)\n            encodeMindMap()\n        }\n    }\n})\n\nfunc shouldNodeShapeSelectorBeDisplayed(selectedItemIds) {\n    shown = false\n    selectedItemIds.forEach((itemId) => {\n        if (rootNode.findById(itemId)) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc selectShapeForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        updateItem(itemId, (item) => {\n            item.shape = panelItem.shape\n            forEach(panelItem.shapeProps, (value, name) => {\n                if (name != 'fill') {\n                    setObjectField(item.shapeProps, name, value)\n                }\n            })\n            node = rootNode.findById(itemId)\n            if (node) {\n                node.data.set('s', panelItem.shape)\n                encodeMindMap()\n            }\n\n            if (panelItem.shape == 'none') {\n                if (!item.textSlots.body) {\n                    setObjectField(item.textSlots, 'body', toJSON(Map('text', 'Add your text...')))\n                }\n                if (item.textSlots.body) {\n                    if (!item.textSlots.body.text || item.textSlots.body.text == '<p></p>') {\n                        setObjectField(item.textSlots.body, 'text', 'Ad your text...')\n                    }\n                }\n            }\n        })\n    })\n}\n\nfunc shouldNodeIconSelectorBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n}\n\n\nfunc selectIconForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node) {\n            setNodeIcon(node, panelItem.id)\n        }\n    })\n}\n\n"}