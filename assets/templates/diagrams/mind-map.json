{"name": "Mind map", "description": "", "args": {"nodes": {"type": "string", "value": "root;x=0;y=0;s=uml_start", "name": "Nodes encoded", "hidden": true}, "connectorType": {"type": "choice", "value": "pretty", "options": ["pretty", "linear", "smooth", "step", "step-cut", "step-smooth"], "name": "Connectors Type"}, "capSize": {"type": "number", "value": 15, "name": "Cap size"}, "capType": {"type": "path-cap", "value": "triangle", "name": "Cap type"}, "iconSize": {"type": "number", "value": 20, "name": "Icon size"}, "showProgress": {"type": "boolean", "value": false, "name": "Show Progress"}, "progressSize": {"type": "number", "value": 20, "name": "Progress Icon Size", "depends": {"showProgress": true}}, "gradientProgress": {"type": "boolean", "value": true, "name": "Gradient Progress", "depends": {"showProgress": true}}, "progressColor": {"type": "color", "value": "#F35B3B", "name": "Progress Icon Color", "depends": {"showProgress": true}}, "progressColor2": {"type": "color", "value": "#E5AB2D", "name": "Progress Icon Color 2", "depends": {"showProgress": true}}, "progressColor3": {"type": "color", "value": "#13D481", "name": "Progress Icon Color 3", "depends": {"showProgress": true, "gradientProgress": true}}}, "preview": "/assets/templates/previews/mind-map.svg", "defaultArea": {"x": 0, "y": 0, "w": 200, "h": 60}, "import": ["./src/item.sch", "./src/control.sch", "./src/mind-map.sch"], "handlers": {"delete": "onDeleteItem(itemId, item)", "area": "onAreaUpdate(itemId, item, area)", "copy": "onCopyItem(itemId, item)", "paste": "onPasteItems(itemId, items)"}, "controls": [{"$-foreach": {"source": "controls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "editor": {"panels": [{"id": "node-progress", "condition": "shouldNodeProgressEditorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectProgressForItems(selectedItemIds, panelItem)", "name": "Select progress", "slotSize": {"width": {"$-expr": "progressSize * 2"}, "height": {"$-expr": "progressSize * 2"}}, "items": [{"$-foreach": {"source": "getAllProgressIconItems()", "it": "it"}, "$-extend": {"$-expr": "toJSON(it)"}}]}, {"id": "node-icon-selector", "condition": "shouldNodeIconSelectorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectIconForItems(selectedItemIds, panelItem)", "name": "Choose icons", "slotSize": {"width": 30, "height": 30}, "items": [{"$-foreach": {"source": "getAllAvailableIcons()", "it": "icon"}, "id": {"$-expr": "icon.id"}, "name": {"$-expr": "icon.id"}, "shape": "image", "area": {"x": -2, "y": -2, "w": 26, "h": 26}, "shapeProps": {"image": {"$-expr": "icon.url"}}}]}, {"id": "node-shape-selector", "condition": "shouldNodeShapeSelectorBeDisplayed(selectedItemIds)", "type": "item-menu", "click": "selectShapeForItems(selectedItemIds, panelItem)", "name": "Select shape", "slotSize": {"width": 80, "height": 40}, "items": [{"id": "rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 0, "fill": {"type": "none"}}}, {"id": "rounded-rect", "shape": "rect", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 10, "fill": {"type": "none"}}}, {"id": "start", "shape": "uml_start", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "ellipse", "shape": "ellipse", "area": {"w": 72, "h": 32}, "shapeProps": {"cornerRadius": 5, "fill": {"type": "none"}}}, {"id": "basic_diamond", "shape": "basic_diamond", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "uml_preparation", "shape": "uml_preparation", "area": {"w": 72, "h": 32}, "shapeProps": {"fill": {"type": "none"}}}, {"id": "label", "shape": "none", "area": {"w": 72, "h": 32}, "textSlots": {"body": {"text": "Simple label"}}}]}, {"id": "node-operations", "condition": "shouldNodeOperationsPanelBeDisplayed(selectedItemIds)", "type": "buttons", "name": "Operations", "click": "onOperationsPanelClick(selectedItemIds, panelItem)", "buttons": [{"id": "insert-new-parent", "name": "Insert new parent"}, {"id": "delete-node-preserve-children", "name": "Delete (preserve children)"}]}]}, "item": {"$-recurse": {"object": {"$-expr": "rootItem"}, "it": "it", "children": "it.childItems", "dstChildren": "childItems"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "`${it.name}`"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "it.getArgs()"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, "init": "\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n    textSlots: Map()\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n\n    setText(slotName, text) {\n        if (!this.textSlots.has(slotName)) {\n            this.textSlots.set(slotName, Map('text', text))\n        } else {\n            this.textSlots.get(slotName).set('text', text)\n        }\n    }\n\n    toJSON() {\n        childItems = this.childItems.map((childItem) => { childItem.toJSON() })\n        result = toJSON(Map(\n            'id', this.id,\n            'childItems', childItems,\n            'name', this.name,\n            'shape', this.shape,\n            'area', Map('x', this.x, 'y', this.y, 'w', this.w, 'h', this.h, 'r', 0, 'sx', 1, 'sy', 1, 'px', 0.5, 'py', 0.5),\n            'shapeProps', this.shapeProps,\n            'args', this.args,\n            'locked', this.locked,\n            'textSlots', this.textSlots,\n        ))\n\n        result\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n}\n\npadding = 120\ncontrolPadding = 40\ncontrols = List()\nrootNode = null\nABS_POS = 'absolutePosition'\n\nconnectorDefaultColor = 'rgba(80,80,80,1.0)'\n\n// rootItem is used for building all of the template items\nrootItem = null\n\nallIcons = Map(\n    'search', '/assets/art/google-cloud/bigquery/bigquery.svg',\n    'time', '/assets/art/azure/General/10006-icon-service-Recent.svg',\n    'cloud', '/assets/art/google-cloud/my_cloud/my_cloud.svg',\n    \"check\", \"/assets/art/icons/check.svg\",\n    \"cross\", \"/assets/art/icons/cross.svg\",\n    \"depressed\", \"/assets/art/icons/depressed.svg\",\n    \"emoji-angry\", \"/assets/art/icons/emoji-angry.svg\",\n    \"emoji-angry-2\", \"/assets/art/icons/emoji-angry-2.svg\",\n    \"emoji-cry\", \"/assets/art/icons/emoji-cry.svg\",\n    \"emoji-dead\", \"/assets/art/icons/emoji-dead.svg\",\n    \"emoji-hah\", \"/assets/art/icons/emoji-hah.svg\",\n    \"emoji-happy\", \"/assets/art/icons/emoji-happy.svg\",\n    \"emoji-heart\", \"/assets/art/icons/emoji-heart.svg\",\n    \"emoji-puke\", \"/assets/art/icons/emoji-puke.svg\",\n    \"emoji-rest\", \"/assets/art/icons/emoji-rest.svg\",\n    \"emoji-rest-2\", \"/assets/art/icons/emoji-rest-2.svg\",\n    \"emoji-rich\", \"/assets/art/icons/emoji-rich.svg\",\n    \"emoji-smile\", \"/assets/art/icons/emoji-smile.svg\",\n    \"emoji-smile-2\", \"/assets/art/icons/emoji-smile-2.svg\",\n    \"emoji-suprised\", \"/assets/art/icons/emoji-suprised.svg\",\n    \"emoji-tired\", \"/assets/art/icons/emoji-tired.svg\",\n    \"emoji-wow\", \"/assets/art/icons/emoji-wow.svg\",\n    \"heart\", \"/assets/art/icons/heart.svg\",\n    \"number-0\", \"/assets/art/icons/number-0.svg\",\n    \"number-1\", \"/assets/art/icons/number-1.svg\",\n    \"number-2\", \"/assets/art/icons/number-2.svg\",\n    \"number-3\", \"/assets/art/icons/number-3.svg\",\n    \"number-4\", \"/assets/art/icons/number-4.svg\",\n    \"number-5\", \"/assets/art/icons/number-5.svg\",\n    \"number-6\", \"/assets/art/icons/number-6.svg\",\n    \"number-7\", \"/assets/art/icons/number-7.svg\",\n    \"number-8\", \"/assets/art/icons/number-8.svg\",\n    \"number-9\", \"/assets/art/icons/number-9.svg\",\n    \"question\", \"/assets/art/icons/question.svg\",\n    \"size-l\", \"/assets/art/icons/size-l.svg\",\n    \"size-m\", \"/assets/art/icons/size-m.svg\",\n    \"size-s\", \"/assets/art/icons/size-s.svg\",\n    \"size-xl\", \"/assets/art/icons/size-xl.svg\",\n    \"size-xs\", \"/assets/art/icons/size-xs.svg\",\n    \"warn\", \"/assets/art/icons/warn.svg\",\n)\n\n\nfunc getAllAvailableIcons() {\n    local icons = List()\n\n    allIcons.forEach((url, id) => {\n        icons.add(toJSON(Map('id', id, 'url', url)))\n    })\n    icons\n}\n\nfunc getNodeIcons(node) {\n    local icons = List()\n    if (node.data.has('icons')) {\n        local iconSet = Set()\n        splitString(node.data.get('icons'), ',').forEach((iconId) => {\n            if (iconId && !iconSet.has(iconId)) {\n                icons.add(iconId)\n                iconSet.add(iconId)\n            }\n        })\n    }\n    icons\n}\n\nfunc encodeIcons(icons) {\n    local encoded = ''\n    icons.forEach((id, idx) => {\n        if (idx > 0) {\n            encoded += ','\n        }\n        encoded += id\n    })\n    encoded\n}\n\n\nfunc setNodeIcon(node, iconId) {\n    local icons = getNodeIcons(node)\n\n    local idx = icons.findIndex((id) => { id == iconId })\n    if (idx < 0) {\n        icons.add(iconId)\n    } else {\n        icons.remove(idx)\n    }\n\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nfunc removeNodeIcon(node, iconId) {\n    local icons = getNodeIcons(node)\n    local idx = icons.findIndex((id) => { id == iconId })\n\n    if (idx >= 0) {\n        icons.remove(idx)\n    }\n    node.data.set('icons', encodeIcons(icons))\n    encodeMindMap()\n}\n\nstruct PinPoint {\n    id: 't'\n    x: 0\n    y: 0\n    normal: Vector(0, -1)\n}\n\n// zone points should be arranged in a counter clock wise polygon\nfunc isPointInsideZone(testPoint, zonePoints) {\n    if (zonePoints.size < 3) {\n        false\n    } else {\n        local lines = List()\n\n        for (i = 0; i < zonePoints.size - 1; i++) {\n            local p1 = zonePoints.get(i)\n            local p2 = zonePoints.get(i+1)\n            lines.add(Math.createLineEquation(p2.x, p2.y, p1.x, p1.y))\n        }\n\n        local isInZone = true\n        for (i = 0; i < lines.size && isInZone; i++) {\n            if (Math.sideAgainstLine(testPoint.x, testPoint.y, lines.get(i)) < 0) {\n                isInZone = false\n            }\n        }\n        isInZone\n    }\n}\n\n\nfunc getPinPointById(pinId, node) {\n    if (pinId == 't') {\n        PinPoint('t', node.w/2, 0,        Vector(0, -1))\n    } else if (pinId == 'b') {\n        PinPoint('b', node.w/2, node.h,   Vector(0, 1))\n    } else if (pinId == 'l') {\n        PinPoint('l', 0,        node.h/2, Vector(-1, 0))\n    } else if (pinId == 'r') {\n        PinPoint('r', node.w,   node.h/2, Vector(1, 0))\n    }\n}\n\n\nfunc encodeMindMap() {\n    nodes = rootNode.encodeTree(' | ', ';')\n}\n\nstruct SuggestedConnection {\n    srcPin: null\n    dstPin: null\n    zonePoints: List()\n}\n\nfunc findPinsForNodes(node, child) {\n    local p1 = Vector(0, 0)\n    local p2 = Vector(node.w, 0)\n    local p3 = Vector(node.w, node.h)\n    local p4 = Vector(0, node.h)\n\n    local topRightV    = Vector(1, -3)\n    local bottomLeftV  = -topRightV\n    local topLeftV     = Vector(-1, -3)\n    local bottomRightV = -topLeftV\n\n    local srcTopPin    = getPinPointById('t', node)\n    local srcBottomPin = getPinPointById('b', node)\n    local srcLeftPin   = getPinPointById('l', node)\n    local srcRightPin  = getPinPointById('r', node)\n\n    local dstTopPin    = getPinPointById('t', child)\n    local dstBottomPin = getPinPointById('b', child)\n    local dstLeftPin   = getPinPointById('l', child)\n    local dstRightPin  = getPinPointById('r', child)\n\n    local childOffset = Vector(child.x, child.y)\n\n    local t = Vector(node.w/2, 0)\n    local t2 = t + Vector(0, -10)\n    local b = Vector(node.w/2, node.h)\n    local b2 = b + Vector(0, 10)\n\n    local connections = List(\n        () => { SuggestedConnection(srcTopPin, dstRightPin, List(p1 + topLeftV, p1, t, t2)) },\n        () => { SuggestedConnection(srcTopPin, dstLeftPin, List(t2, t, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstLeftPin, List(p3 + bottomRightV, p3, b, b2)) },\n        () => { SuggestedConnection(srcBottomPin, dstRightPin, List(b2, b, p4, p4 + bottomLeftV)) },\n\n        () => { SuggestedConnection(srcRightPin, dstLeftPin, List(p2 + topRightV, p2, p3, p3 + bottomRightV)) },\n        () => { SuggestedConnection(srcLeftPin, dstRightPin, List(p4 + bottomLeftV, p4, p1, p1 + topLeftV)) },\n        () => { SuggestedConnection(srcTopPin, dstBottomPin, List(p1 + topLeftV, p1, p2, p2 + topRightV)) },\n        () => { SuggestedConnection(srcBottomPin, dstTopPin, List(p3 + bottomRightV, p3, p4, p4 + bottomLeftV)) },\n    )\n\n    local srcPin = srcRightPin\n    local dstPin = dstLeftPin\n    local matches = false\n\n    for (local i = 0; i < connections.size && !matches; i++) {\n        local connection = connections.get(i)()\n        srcPin = connection.srcPin\n        dstPin = connection.dstPin\n\n        local testPoint = Vector(dstPin.x, dstPin.y) + childOffset\n        matches = isPointInsideZone(testPoint, connection.zonePoints)\n    }\n\n    List(srcPin, dstPin)\n}\n\nstruct PathPoint {\n    t: 'B'\n    x: 0\n    y: 0\n    x1: 0\n    y1: 0\n    x2: 0\n    y2: 0\n}\n\nfunc updatePrettyConnector(connector, pin1, pin2, childOffset, node, parent) {\n    connector.id = `connector-pretty-${parent.id}-${node.id}`\n    connector.shape = 'path'\n\n    // rotating pin by 90 degrees clockwise\n    local Vx = -pin1.normal.y * capSize / 2\n    local Vy = pin1.normal.x * capSize / 2\n\n    local d1 = 0\n    local d2 = 0\n\n    if (abs(pin1.normal.x * pin2.normal.x + pin1.normal.x * pin2.normal.x) > 0.5) {\n        // the normals are not perpendicular to each other\n        // local d = sqrt((pin2.x + childOffset.x - pin1.x) * (pin2.x + childOffset.x - pin1.x) + (pin2.y + childOffset.y - pin1.y) * (pin2.y + childOffset.y - pin1.y)) / 2\n        local x2 = pin2.x + childOffset.x\n        local y2 = pin2.y + childOffset.y\n        // creating line that is perpendicular to the pin1 normal\n        local line = Math.createLineEquation(x2, y2, x2 - pin1.normal.y, y2 + pin1.normal.x)\n        d1 = Math.distanceFromPointToLine(pin1.x, pin1.y, line) / 2\n        d2 = d1\n    } else {\n        // normals are perpendicular to each other\n        local x2 = pin2.x + childOffset.x\n        local y2 = pin2.y + childOffset.y\n        local line2 = Math.createLineEquation(x2, y2, x2 + pin2.normal.x, y2 + pin2.normal.y)\n        d1 = Math.distanceFromPointToLine(pin1.x, pin1.y, line2) / 2\n\n        local line1 = Math.createLineEquation(pin1.x, pin1.y, pin1.x + pin1.normal.x, pin1.y + pin1.normal.y)\n        d2 = Math.distanceFromPointToLine(x2, y2, line1) / 2\n    }\n\n    local Nx = pin1.normal.x * d1\n    local Ny = pin1.normal.y * d1\n    local Mx = pin2.normal.x * d2\n    local My = pin2.normal.y * d2\n\n    local Ax = pin1.x + Vx\n    local Ay = pin1.y + Vy\n    local Bx = pin1.x - Vx\n    local By = pin1.y - Vy\n\n    local minX = min(Ax, Bx, pin1.x, pin2.x + childOffset.x)\n    local maxX = max(Ax, Bx, pin1.x, pin2.x + childOffset.x)\n    local minY = min(Ay, By, pin1.y, pin2.y + childOffset.y)\n    local maxY = max(Ay, By, pin1.y, pin2.y + childOffset.y)\n\n    local points = List(\n        PathPoint('B', Ax, Ay, Nx, Ny, -Vx, -Vy),\n        PathPoint('B', Bx, By, Vx, Vy, Nx, Ny),\n        PathPoint('B', pin2.x + childOffset.x, pin2.y + childOffset.y, Mx, My, Mx, My),\n    )\n\n    local dx = maxX - minX\n    local dy = maxY - minY\n\n    if (dx > 0.0001 && dy > 0.0001) {\n        points.forEach((p) => {\n            p.x = 100 * (p.x - minX) / dx\n            p.y = 100 * (p.y - minY) / dy\n            p.x1 = 100 * p.x1 / dx\n            p.y1 = 100 * p.y1 / dy\n            p.x2 = 100 * p.x2 / dx\n            p.y2 = 100 * p.y2 / dy\n        })\n    }\n\n    connector.x = minX\n    connector.y = minY\n    connector.w = dx\n    connector.h = dy\n\n    connector.shapeProps.set('paths', List(\n        Map(\n            'id', 'a',\n            'closed', true,\n            'pos', 'relative',\n            'points', points\n        )\n    ))\n    connector.shapeProps.set('strokeColor', connectorDefaultColor)\n    connector.shapeProps.set('strokeSize', 2)\n    connector.shapeProps.set('fill', Map('type', 'solid', 'color', connectorDefaultColor))\n}\n\nfunc updateConnector(connector, pin1, pin2, childOffset, node, parent) {\n    connector.args.set('templateIgnoredProps', List('name', 'shapeProps.fill', 'shapeProps.stroke*'))\n\n    if (connectorType == 'pretty') {\n        updatePrettyConnector(connector, pin1, pin2, childOffset, node, parent)\n    } else {\n        connector.shapeProps.set('points', List(\n            Map('id', pin1.id, 'x', pin1.x, 'y', pin1.y, 'nx', pin1.normal.x, 'ny', pin1.normal.y),\n            Map('id', pin2.id, 'x', pin2.x + childOffset.x, 'y', pin2.y + childOffset.y, 'nx', pin2.normal.x, 'ny', pin2.normal.y)\n        ))\n\n        connector.shapeProps.set('strokeColor', connectorDefaultColor)\n        connector.shapeProps.set('sourceItem', `#${parent.id}`)\n        connector.shapeProps.set('sourcePin', pin1.id)\n        connector.shapeProps.set('destinationItem', `#${node.id}`)\n        connector.shapeProps.set('destinationPin', pin2.id)\n        connector.shapeProps.set('sourceCap', 'empty')\n        connector.shapeProps.set('destinationCap', capType)\n        connector.shapeProps.set('destinationCapSize', capSize)\n        connector.shapeProps.set('smoothing', connectorType)\n    }\n}\n\n\nfunc updateConnectorForMovingNode(node) {\n    local parent = node.parent\n    local connectorId = if (connectorType == 'pretty') {\n        `connector-pretty-${parent.id}-${node.id}`\n    } else {\n        `connector-${parent.id}-${node.id}`\n    }\n\n    local connector = Item(connectorId, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n    local childOffset = Vector(node.x, node.y)\n    local pins = findPinsForNodes(parent, node)\n    local pin1 = pins.get(0)\n    local pin2 = pins.get(1)\n    updateConnector(connector, pin1, pin2, childOffset, node, parent)\n\n    updateItem(connectorId, (item) => {\n        item.shape = connector.shape\n        item.area.x = connector.x\n        item.area.y = connector.y\n        item.area.w = connector.w\n        item.area.h = connector.h\n        item.shapeProps = toJSON(connector.shapeProps)\n    })\n}\n\nfunc prepareConnectorForNode(node, parent) {\n    local connector = Item(`connector-${parent.id}-${node.id}`, `${node.id} -> ${parent.id}`, 'connector', 0, 0, 100, 50, Map())\n\n    local childOffset = Vector(node.x, node.y)\n\n    local pins = findPinsForNodes(parent, node)\n    local pin1 = pins.get(0)\n    local pin2 = pins.get(1)\n\n    updateConnector(connector, pin1, pin2, childOffset, node, parent)\n\n    if (parent.tempData.has('connectors')) {\n        parent.tempData.get('connectors').add(connector)\n    } else {\n        parent.tempData.set('connectors', List(connector))\n    }\n\n    pin2.id\n}\n\n\nfunc updateAbsoluteNodePosition(node) {\n    local x = parseInt(node.data.get('x'))\n    local y = parseInt(node.data.get('y'))\n    local localPos = Vector(x, y)\n\n    local pos = (if (node.parent) {\n        if (node.parent.tempData.has(ABS_POS)) {\n            node.parent.tempData.get(ABS_POS) + localPos\n        } else {\n            parentPos = updateAbsoluteNodePosition(node.parent)\n            parentPos + localPos\n        }\n    } else {\n        localPos\n    })\n\n    node.tempData.set(ABS_POS, pos)\n\n    pos\n}\n\n\nfunc createProgressIconItems(nodeId, percent, color, x, y) {\n    local items = List()\n\n    if (gradientProgress) {\n        local t = if (percent <= 50) { percent / 50 } else { (percent - 50) / 50 }\n        local c1 = decodeColor(if (percent <= 50) { (progressColor) } else { progressColor2 })\n        local c2 = decodeColor(if (percent <= 50) { (progressColor2) } else { progressColor3 })\n        color = c1.gradient(c2, t).encode()\n    }\n\n    local isNotFull = percent < 99.5\n\n    items.add(Item(\n        `${nodeId}_progress_stroke`, 'progress container', 'ellipse', x, y, progressSize, progressSize, Map(\n            'fill', if (isNotFull) { Map('type', 'none') } else { Map('type', 'solid', 'color', color) },\n            'strokeColor', color,\n            'strokeSize', 3\n        ), List(), Map(\n            'mindMapType', 'progress',\n            'mindMapNodeId', nodeId,\n        )\n    ))\n    if (percent > 0.5 && isNotFull) {\n        items.add(Item(\n            `${nodeId}_progress`, 'progress', 'pie_segment', x, y, progressSize, progressSize, Map(\n                'strokeSize', 0,\n                'strokeColor', color,\n                'fill', Map('type', 'solid', 'color', color),\n                'percent', percent\n            ), List(), Map(\n                'mindMapType', 'progress',\n                'mindMapNodeId', nodeId,\n            )\n        ))\n    }\n    items\n}\n\nfunc createNodeIconItems(node) {\n    local items = List()\n\n    local margin = 5\n\n    if (showProgress) {\n        local percent = 0\n        local color = progressColor\n        if (node.children.size == 0) {\n            color = progressColor2\n        }\n        if (node.data.has('p')) {\n            percent = max(0, min(parseInt(node.data.get('p')), 100))\n        }\n        local x = 10\n        local y = node.h / 2 - progressSize / 2\n\n        items.extendList(createProgressIconItems(node.id, percent, color, x, y))\n    }\n\n    local progressOffset = if (showProgress) { margin + progressSize } else { 0 }\n\n    getNodeIcons(node).forEach((iconId, idx) => {\n        local x = (iconSize + margin) * idx + 10 + progressOffset\n        local y = node.h / 2 - iconSize / 2\n        items.add(Item(\n            `${node.id}_icon_${iconId}`, iconId, 'image', x, y, iconSize, iconSize, Map('image', allIcons.get(iconId)), List(), Map(\n                'mindMapType', 'icon',\n                'mindMapIcon', iconId,\n                'mindMapNodeId', node.id,\n            )\n        ))\n    })\n\n    items\n}\n\nfunc buildTemplateItems(rootNode) {\n    rootNode.map((node, childItems) => {\n        local x = node.data.get('x')\n        local y = node.data.get('y')\n        local w = node.data.get('w')\n        local h = node.data.get('h')\n\n        childItems.extendList()\n\n        createNodeIconItems(node).forEach((iconItem, i) => {\n            childItems.insert(i, iconItem)\n        })\n\n        if (node.tempData.has('connectors')) {\n            local connectors = node.tempData.get('connectors')\n            if (connectors) {\n                connectors.forEach((connector, i) => {\n                    childItems.insert(i, connector)\n                })\n            }\n        }\n\n        local shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n        local item = Item(node.id, `item ${node.id}`, shape, x, y, w, h, Map(), childItems, Map(\n            'mindMapType', 'node'\n        ))\n\n        if (node.tempData.has('sourceItem')) {\n            srcItem = node.tempData.get('sourceItem')\n            if (srcItem) {\n                item.shape = srcItem.shape\n                item.shapeProps = fromJSON(srcItem.shapeProps)\n                item.textSlots = fromJSON(srcItem.textSlots)\n            }\n        } else {\n            item.textSlots = Map('body', Map(\n                'text', '',\n                'paddingLeft', 5,\n                'paddingRight', 5,\n                'paddingTop', 5,\n                'paddingBottom', 5,\n            ))\n        }\n\n        item.args.set('templateIgnoredProps', List('name', 'shape', 'shapeProps.*'))\n        item.locked = false\n        if (node.id != rootNode.id) {\n            item.args.set('tplArea', 'controlled')\n        }\n        item.args.set('tplRotation', 'off')\n        item.args.set('tplConnector', 'off')\n\n        if (shape == 'none') {\n            item.setText('body', 'Add your text...')\n        }\n        item\n    })\n}\n\nfunc findProperPositionValue(node, placement) {\n    local values = List()\n\n    node.children.forEach((childNode) => {\n        if (placement == 'top') {\n            if (childNode.y < 0) {\n                values.add(childNode.y)\n            }\n        } else if (placement == 'bottom') {\n            if (childNode.y > 0) {\n                values.add(childNode.y)\n            }\n        } else if (placement == 'left') {\n            if (childNode.x < 0) {\n                values.add(childNode.x)\n            }\n        } else if (placement == 'right') {\n            if (childNode.x > 0) {\n                values.add(childNode.x)\n            }\n        }\n    })\n\n    values.sort((a, b) => { if (a < b) { -1 } else { 1 } })\n\n    local w = max(1, node.w)\n    local h = max(1, node.h)\n\n    if (values.size == 0) {\n        if (placement == 'top') {\n            - padding - h\n        } else if (placement == 'bottom') {\n            node.h + padding\n        } else if (placement == 'left') {\n            - padding - w\n        } else if (placement == 'right') {\n            node.w + padding\n        }\n    } else {\n        local i = floor(values.size / 2)\n        values.get(i)\n    }\n}\n\nfunc createNewChildFor(nodeId, placement) {\n    local node = rootNode.findById(nodeId)\n    if (node) {\n        local x = 0\n        local y = 0\n        local w = max(1, node.w)\n        local h = max(1, node.h)\n        local shape = if (node.data.has('s')) { node.data.get('s') } else { 'rect' }\n\n        if (node.children.size > 0) {\n            local childNode = node.children.get(0)\n            if (childNode.data.has('s')) {\n                shape = if (childNode.data.has('s')) { childNode.data.get('s') } else { shape }\n            }\n\n            w = max(1, childNode.w)\n            h = max(1, childNode.h)\n        }\n\n        local correctiveVector = Vector(0, h * 0.1)\n\n        if (placement == 'top') {\n            y = findProperPositionValue(node, placement)\n            x = node.w / 2 - w / 2\n            correctiveVector = Vector(w * 0.2, 0)\n        } else if (placement == 'bottom') {\n            y = findProperPositionValue(node, placement)\n            x = node.w / 2 - w / 2\n            correctiveVector = Vector(w * 0.2, 0)\n        } else if (placement == 'left') {\n            x = findProperPositionValue(node, placement)\n            y = node.h / 2 - h / 2\n        } else if (placement == 'right') {\n            x = findProperPositionValue(node, placement)\n            y = node.h / 2 - h / 2\n        }\n\n        local childAreas = node.children.map((childNode) => { Area(childNode.x, childNode.y, childNode.w, childNode.h) })\n\n        func overlapsChildren(area) {\n            local overlaps = false\n            for (local i = 0; !overlaps && i < childAreas.size; i++) {\n                overlaps = area.overlaps(childAreas.get(i))\n            }\n            overlaps\n        }\n\n        local overlaps = true\n        local tries = 0\n\n        local area\n\n        while(overlaps && tries < 1000) {\n            local direction = if (tries % 2 == 0) { 1 } else { -1 }\n            local displacement = correctiveVector * tries * direction\n            area = Area(x + displacement.x, y + displacement.y, w, h)\n            overlaps = overlapsChildren(area)\n            tries++\n        }\n\n        local childNode = TreeNode(uid(), Map('x', area.x, 'y', area.y, 'w', w, 'h', h, 's', shape, 'p', 0))\n        node.children.add(childNode)\n\n        updateProgress(rootNode)\n\n        encodeMindMap()\n    }\n}\n\nfunc shouldNodeShapeSelectorBeDisplayed(selectedItemIds) {\n    local shown = false\n    selectedItemIds.forEach((itemId) => {\n        if (rootNode.findById(itemId)) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc selectShapeForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        updateItem(itemId, (item) => {\n            item.shape = panelItem.shape\n            forEach(panelItem.shapeProps, (value, name) => {\n                if (name != 'fill') {\n                    setObjectField(item.shapeProps, name, value)\n                }\n            })\n            local node = rootNode.findById(itemId)\n            if (node) {\n                node.data.set('s', panelItem.shape)\n                encodeMindMap()\n            }\n\n            if (panelItem.shape == 'none') {\n                if (!item.textSlots.body) {\n                    setObjectField(item.textSlots, 'body', toJSON(Map('text', 'Add your text...')))\n                }\n                if (item.textSlots.body) {\n                    if (!item.textSlots.body.text || item.textSlots.body.text == '<p></p>') {\n                        setObjectField(item.textSlots.body, 'text', 'Ad your text...')\n                    }\n                }\n            }\n        })\n    })\n}\n\nfunc shouldNodeIconSelectorBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n}\n\n\nfunc selectIconForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        local node = rootNode.findById(itemId)\n        if (node) {\n            setNodeIcon(node, panelItem.id)\n        }\n    })\n}\n\nfunc shouldNodeProgressEditorBeDisplayed(selectedItemIds) {\n    if (showProgress) {\n        local showPanel = false\n        selectedItemIds.forEach((itemId) => {\n            local node = rootNode.findById(itemId)\n            if (node && node.children.size == 0) {\n                showPanel = true\n            }\n        })\n        showPanel\n    } else {\n        false\n    }\n}\n\nfunc getAllProgressIconItems() {\n    List(0, 25, 50, 75, 100).map((percent) => {\n        items = createProgressIconItems(`icon-${percent}`, percent, progressColor2, 0, 0)\n        Item(`progress_${percent}_container`, `${percent}`, 'none', 2, 2, progressSize, progressSize, Map(), items, Map(\n            'mindMapProgress', percent\n        )).toJSON()\n    })\n}\n\nfunc updateProgress(node) {\n    if (node.children.size > 0) {\n        local sumProgress = 0\n        node.children.forEach((childNode) => {\n            sumProgress += updateProgress(childNode)\n        })\n\n        local totalProgress = sumProgress / node.children.size\n        node.data.set('p', totalProgress)\n        totalProgress\n    } else {\n        if (node.data.has('p')) {\n            node.data.get('p')\n        } else {\n            0\n        }\n    }\n}\n\nfunc selectProgressForItems(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        local node = rootNode.findById(itemId)\n        if (node && node.children.size == 0) {\n            node.data.set('p', panelItem.args.mindMapProgress)\n        }\n    })\n\n    updateProgress(rootNode)\n\n    encodeMindMap()\n}\n\n// triggered when item area changes as a result of edit box modifications\n// the handler is supposed to mutate the area object in case the area is changed\nfunc onAreaUpdate(itemId, item, area) {\n    local node = rootNode.findById(itemId)\n    if (node) {\n        node.data.set('x', area.x)\n        node.data.set('y', area.y)\n        node.data.set('w', area.w)\n        node.data.set('h', area.h)\n\n        if (node.parent) {\n            updateConnectorForMovingNode(node)\n        }\n        encodeMindMap()\n    }\n}\n\n// Template special function. Triggered when user deletes templated item\nfunc onDeleteItem(itemId, item) {\n    local node\n    if (item.args.mindMapType == 'icon') {\n        node = rootNode.findById(item.args.mindMapNodeId)\n        if (node) {\n            removeNodeIcon(node, item.args.mindMapIcon)\n        }\n    } else if (item.args.mindMapType == 'node') {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            node.parent.children.remove(node.siblingIdx)\n            updateProgress(rootNode)\n            encodeMindMap()\n        }\n    }\n}\n\nfunc onCopyItem(itemId, item) {\n    local node = rootNode.findById(itemId)\n    if (node) {\n        encodedNode = node.encodeTree(' | ', ';')\n        setObjectField(item.args, 'mindMap_EncodedNode', encodedNode)\n    }\n}\n\nfunc onPasteItems(itemId, items) {\n    local dstNode = rootNode.findById(itemId)\n    if (dstNode) {\n        items.forEach((item) => {\n            if (item.args && item.args.mindMap_EncodedNode) {\n                local newRootNode = decodeTree(item.args.mindMap_EncodedNode, ' | ', ';')\n\n                local nodesById = Map()\n                newRootNode.traverse((node) => {\n                    nodesById.set(node.id, node)\n                    node.x = parseInt(node.data.get('x'))\n                    node.y = parseInt(node.data.get('y'))\n                    node.w = parseInt(node.data.get('w'))\n                    node.h = parseInt(node.data.get('h'))\n                    node.id = uid()\n                })\n\n                local traverseItems = (item) => {\n                    if (item.args.templated && item.args.templatedId && nodesById.has(item.args.templatedId)) {\n                        local node = nodesById.get(item.args.templatedId)\n                        // this will be used when building items to make sure that all shapeProps and textSlots fields are copied as well\n                        // as those could be overriden by the user\n                        node.tempData.set('sourceItem', item)\n                    }\n                    if (item.childItems) {\n                        item.childItems.forEach(traverseItems)\n                    }\n                }\n                traverseItems(item)\n                newRootNode.attachTo(dstNode)\n\n                if (dstNode.parent && dstNode.x < 0) {\n                    newRootNode.x = - padding - newRootNode.w\n                    newRootNode.y = 0\n                } else {\n                    newRootNode.x = dstNode.w + padding\n                    newRootNode.y = 0\n                }\n                newRootNode.data.set('x', newRootNode.x)\n                newRootNode.data.set('y', newRootNode.y)\n                autoAlignChildNodes(newRootNode, newRootNode.x < 0)\n            }\n        })\n\n        reindexTree(rootNode)\n        updateProgress(rootNode)\n        rootItem = buildTemplateItems(rootNode)\n        rootItem.name = 'Mind map'\n        rootItem.w = width\n        rootItem.h = height\n\n        encodeMindMap()\n    }\n}\n\n\nfunc autoAlignChildNodes(node, toLeft) {\n    local vPad = 20\n    local totalHeight = node.children.size * vPad\n\n    node.children.forEach((childNode) => {\n        totalHeight += childNode.h\n    })\n\n    local y = node.h/2 - totalHeight/2\n\n    node.children.forEach((childNode) => {\n        childNode.y = y\n        y = y + childNode.h + vPad\n\n        if (toLeft) {\n            childNode.x = -childNode.w - padding\n        } else {\n            childNode.x = node.w + padding\n        }\n\n        childNode.data.set('x', childNode.x)\n        childNode.data.set('y', childNode.y)\n        autoAlignChildNodes(childNode, toLeft)\n    })\n}\n\n\nfunc reindexTree(rootNode) {\n    rootNode.traverse((node, parent) => {\n        local x = parseInt(node.data.get('x'))\n        local y = parseInt(node.data.get('y'))\n        local w = parseInt(node.data.get('w'))\n        local h = parseInt(node.data.get('h'))\n        local p = 0\n        if (node.data.has('p')) {\n            p = parseInt(node.data.get('p'))\n        }\n\n        node.data.set('x', x)\n        node.data.set('y', y)\n        node.data.set('w', w)\n        node.data.set('h', h)\n        node.data.set('p', p)\n\n        node.x = x\n        node.y = y\n        local pos = updateAbsoluteNodePosition(node)\n\n        local addingControl = (location, placement, cx, cy) => {\n            Control(`add_child_${location}`, Map('nodeId', node.id), `createNewChildFor(control.data.nodeId, '${location}')`, cx, cy, 20, 20, '+', placement, node.id)\n        }\n\n        if (parent) {\n            node.w = w\n            node.h = h\n            local srcPinId = prepareConnectorForNode(node, parent)\n            if (srcPinId == 't') {\n                controls.add(addingControl('bottom', 'TL', pos.x + node.w / 2 - 10, pos.y + node.h + controlPadding))\n            } else if (srcPinId == 'b') {\n                controls.add(addingControl('top', 'BL', pos.x + node.w / 2 - 10, pos.y - controlPadding))\n            } else if (srcPinId == 'l') {\n                controls.add(addingControl('right', 'TL', pos.x + node.w + controlPadding, pos.y + node.h / 2 - 10))\n            } else if (srcPinId == 'r') {\n                controls.add(addingControl('left', 'TR', pos.x - controlPadding, pos.y + node.h / 2 - 10))\n            }\n        } else {\n            node.w = width\n            node.h = height\n\n            controls.extendList(List(\n                addingControl('left', 'TR', -controlPadding, node.h / 2 - 10),\n                addingControl('right', 'TL', node.w + controlPadding, node.h / 2 - 10)\n            ))\n        }\n    })\n}\n\n\nfunc shouldNodeOperationsPanelBeDisplayed(selectedItemIds) {\n    shouldNodeShapeSelectorBeDisplayed(selectedItemIds)\n    local shown = false\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node && node.parent) {\n            shown = true\n        }\n    })\n    shown\n}\n\nfunc onOperationsPanelClick(selectedItemIds, panelItem) {\n    selectedItemIds.forEach((itemId) => {\n        node = rootNode.findById(itemId)\n        if (node) {\n            if (panelItem.id == 'insert-new-parent' && node.parent) {\n                insertNewParentFor(node)\n            } else if (panelItem.id == 'delete-node-preserve-children' && node.parent) {\n                deleteNodePreservingChildren(node)\n            }\n        }\n    })\n}\n\nfunc insertNewParentFor(node) {\n    local oldParent = node.parent\n    local dx = node.x - node.parent.x\n    local dy = node.y - node.parent.y\n\n    local found = false\n    for (local i = 0; !found && i < node.parent.children.size; i++) {\n        local childNode = node.parent.children.get(i)\n        if (childNode.id == node.id) {\n            found = true\n            node.parent.children.remove(i)\n        }\n    }\n\n    local newParent = TreeNode(uid())\n    node.data.forEach((value, name) => { newParent.data.set(name, value) })\n    newParent.x = node.x\n    newParent.y = node.y\n    newParent.w = node.w\n    newParent.h = node.h\n\n    node.attachTo(newParent)\n    newParent.attachTo(oldParent)\n    updateProgress(rootNode)\n    encodeMindMap()\n}\n\nfunc deleteNodePreservingChildren(node) {\n    local found = false\n    local parent = node.parent\n    for (local i = 0; !found && i < parent.children.size; i++) {\n        if (node.id == parent.children.get(i).id) {\n            parent.children.remove(i)\n            local oldSize = parent.children.size - 1\n            parent.children.extendList(node.children)\n            node.children.forEach((childNode, idx) => {\n                childNode.parent = parent\n                childNode.siblingIdx = oldSize + idx\n            })\n        }\n    }\n\n    updateProgress(rootNode)\n    encodeMindMap()\n}\n\nrootNode = decodeTree(nodes, ' | ', ';')\nreindexTree(rootNode)\n\n if (context.phase == 'build') {\n    rootItem = buildTemplateItems(rootNode)\n    rootItem.name = 'Mind map'\n    rootItem.w = width\n    rootItem.h = height\n}\n\n\n"}