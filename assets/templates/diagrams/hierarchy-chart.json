{"name": "Hierarchy chart", "description": "", "args": {"cornerRadius": {"type": "number", "value": 10, "name": "Corner radius", "min": 0}, "nodes": {"type": "string", "value": "0,1,N,2,N,N", "name": "Nodes encoded", "hidden": true}, "vGap": {"type": "number", "value": 60, "name": "Vertical Gap", "min": 0}, "hGap": {"type": "number", "value": 20, "name": "Horizontal Gap", "min": 0}, "connectorType": {"type": "choice", "value": "smooth", "options": ["linear", "smooth", "step", "step-cut", "step-smooth"], "name": "Connectors Type"}, "capType": {"type": "path-cap", "value": "triangle", "name": "Cap type"}, "capSize": {"type": "number", "value": 15, "name": "Cap size"}}, "preview": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhodG1sPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmlld0JveD0iLTEwIC0xMCAzNDAgMjIwIj48ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwMCwwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJaZ2txU09HSVkiIGRhdGEtaXRlbS1pZD0iWmdrcVNPR0lZIj4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPiA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiPjxnPjxnPjxnPiA8L2c+IDxwYXRoIGQ9Ik0gMTAwIDYwICBMIDIwIDYwIGEgMjAgMjAgMCAwIDEgLTIwIC0yMCAgTCAwIDIwICBhIDIwIDIwIDAgMCAxIDIwIC0yMCAgIEwgMTAwIDAgICBhIDIwIDIwIDAgMCAxIDIwIDIwICBMIDEyMCA0MCAgIGEgMjAgMjAgMCAwIDEgLTIwIDIwIFoiIHN0cm9rZS13aWR0aD0iMnB4IiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWRhc2hhcnJheT0iIiBzdHJva2UtZGFzaG9mZnNldD0iMCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1aZ2txU09HSVkiLz4gICAgICAgPC9nPjwvZz4KPGcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDE0MCkgcm90YXRlKDApIiBkYXRhLXN2Zy1pdGVtLWNvbnRhaW5lci1pZD0iaDdSV0p0UTBLIiBkYXRhLWl0ZW0taWQ9Img3UldKdFEwSyI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9InJnYmEoMjQwLDI0MCwyNDAsMS4wKSIvPjwvZz48L2c+PC9nPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ii8+PC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItaDdSV0p0UTBLIi8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjAsNjApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9ImRwUXQ3Tlk4dyIgZGF0YS1pdGVtLWlkPSJkcFF0N05ZOHciPiAgPGcgc3R5bGU9Im9wYWNpdHk6IDE7IG1peC1ibGVuZC1tb2RlOiBub3JtYWw7Ij4gPGRlZnMvPiA8ZyBmaWx0ZXI9IiI+PGcgbW9kZT0iZWRpdCIgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCAwIEMgMTAwIDM4Ljg3IDAgIDIxLjEzIDAgNjAgIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2UtbGluZWpvaW46IHJvdW5kOyIvPiA8Zz48cGF0aCBkPSJNIC01IDYwIEwgMCA4MCBMIDUgNjAgIHogIiBzdHJva2U9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PC9nPiAgIDwvZz4gIDxnIGlkPSJhbmltYXRpb24tY29udGFpbmVyLWRwUXQ3Tlk4dyIvPiAgICAgICA8L2c+PC9nPgo8ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMCwxNDApIHJvdGF0ZSgwKSIgZGF0YS1zdmctaXRlbS1jb250YWluZXItaWQ9Ik1Nanh4QXptVzQiIGRhdGEtaXRlbS1pZD0iTU1qeHhBem1XNCI+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsgbWl4LWJsZW5kLW1vZGU6IG5vcm1hbDsiPiA8ZGVmcy8+IDxnIGZpbHRlcj0iIj4gPGcgc3R5bGU9Im9wYWNpdHk6IDE7Ij48Zz48Zz48Zz4gPC9nPiA8cGF0aCBkPSJNIDEwMCA2MCAgTCAyMCA2MCBhIDIwIDIwIDAgMCAxIC0yMCAtMjAgIEwgMCAyMCAgYSAyMCAyMCAwIDAgMSAyMCAtMjAgICBMIDEwMCAwICAgYSAyMCAyMCAwIDAgMSAyMCAyMCAgTCAxMjAgNDAgICBhIDIwIDIwIDAgMCAxIC0yMCAyMCBaIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlPSJyZ2JhKDMwLDMwLDMwLDEuMCkiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0icmdiYSgyNDAsMjQwLDI0MCwxLjApIi8+PC9nPjwvZz48L2c+ICA8ZyBzdHlsZT0ib3BhY2l0eTogMTsiLz48L2c+ICA8ZyBpZD0iYW5pbWF0aW9uLWNvbnRhaW5lci1NTWp4eEF6bVc0Ii8+ICAgICAgIDwvZz48L2c+CjxnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTYwLDYwKSByb3RhdGUoMCkiIGRhdGEtc3ZnLWl0ZW0tY29udGFpbmVyLWlkPSJSSkhNU2FYUTYiIGRhdGEtaXRlbS1pZD0iUkpITVNhWFE2Ij4gIDxnIHN0eWxlPSJvcGFjaXR5OiAxOyBtaXgtYmxlbmQtbW9kZTogbm9ybWFsOyI+IDxkZWZzLz4gPGcgZmlsdGVyPSIiPjxnIG1vZGU9ImVkaXQiIHN0eWxlPSJvcGFjaXR5OiAxOyI+PGc+IDwvZz4gPHBhdGggZD0iTSAwIDAgQyAwIDM4Ljg3IDEwMCAgMjEuMTMgMTAwIDYwICIgc3Ryb2tlLXdpZHRoPSIycHgiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2UtZGFzaGFycmF5PSIiIHN0cm9rZS1kYXNob2Zmc2V0PSIwIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlLWxpbmVqb2luOiByb3VuZDsiLz4gPGc+PHBhdGggZD0iTSA5NSA2MCBMIDEwMCA4MCBMIDEwNSA2MCAgeiAiIHN0cm9rZT0icmdiYSgzMCwzMCwzMCwxLjApIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9InJnYmEoMzAsMzAsMzAsMS4wKSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L2c+ICAgPC9nPiAgPGcgaWQ9ImFuaW1hdGlvbi1jb250YWluZXItUkpITVNhWFE2Ii8+ICAgICAgIDwvZz48L2c+PC9zdmc+", "defaultArea": {"x": 0, "y": 0, "w": 120, "h": 60}, "import": ["./src/treenode.sch"], "init": "struct TreeNode {\n    id: uid()\n    data: Map()\n    parent: null\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n    siblingIdx: 0\n    level: 0\n    children: List()\n    tempData: Map()\n\n    findById(nodeId) {\n        if (this.id == nodeId) {\n            this\n        } else {\n            foundNode = null\n            for (i = 0; i < this.children.size && !foundNode; i++) {\n                foundNode = this.children.get(i).findById(nodeId)\n            }\n            foundNode\n        }\n    }\n\n    map(callback) {\n        mappedChildren = List()\n        this.children.forEach((childNode) => {\n            mappedChildren.add(childNode.map(callback))\n        })\n        callback(this, mappedChildren)\n    }\n\n    attachTo(parentNode) {\n        this.parent = parentNode\n        this.siblingIdx = parentNode.children.size\n        parentNode.children.add(this)\n    }\n\n    attachChildAtIndex(childNode, idx) {\n        childNode.parent = this\n        this.children.insert(idx, childNode)\n        this.children.forEach((node, nodeIdx) => {\n            node.siblingIdx = nodeIdx\n        })\n    }\n\n    encodeTree(nodeSeparator, paramSeparator) {\n        encoded = this.id\n        this.data.forEach((value, name) => {\n            encoded = encoded + paramSeparator + name + '=' + value\n        })\n        this.children.forEach((childNode) => {\n            childEncoded = childNode.encodeTree(nodeSeparator, paramSeparator)\n            encoded += nodeSeparator + childEncoded\n        })\n        encoded + nodeSeparator + 'N'\n    }\n\n    reindex(callback) {\n        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }\n        if (this.children.size > 0) {\n            this.children.forEach((childNode) => {\n                childNode.reindex(callback)\n            })\n        }\n        if (callback) {\n            callback(this)\n        }\n    }\n\n    traverse(callback) {\n        callback(this, this.parent)\n        this.children.forEach((childNode) => {\n            childNode.traverse(callback)\n        })\n    }\n}\n\ndecodeTreeNode = (nodeEncoded, paramSeparator) => {\n    nodeParts = splitString(nodeEncoded, paramSeparator)\n    nodeId = nodeParts.shift()\n    nodeData = Map()\n    nodeParts.forEach((encodedParameter) => {\n        paramParts = splitString(encodedParameter, '=')\n        if (paramParts.size == 2) {\n            nodeData.set(paramParts.get(0), paramParts.get(1))\n        }\n    })\n\n    TreeNode(nodeId, nodeData)\n}\n\ndecodeTree = (encodedText, nodeSeparator, paramSeparator) => {\n    nodeList = splitString(encodedText, nodeSeparator)\n    rootNode = decodeTreeNode(nodeList.shift(), paramSeparator)\n    currentNode = rootNode\n    while(nodeList.size > 0) {\n        nodeEncoded = nodeList.shift()\n        if (nodeEncoded == 'N') {\n            parent = currentNode.parent\n            if (!parent) {\n                parent = rootNode\n            }\n            currentNode = parent\n        } else {\n            newNode = decodeTreeNode(nodeEncoded, paramSeparator)\n            newNode.attachTo(currentNode)\n            currentNode = newNode\n        }\n    }\n    rootNode\n}\n\n\nstruct Connector {\n    id: ''\n    srcId: ''\n    dstId: ''\n    p1: Vector(0, 0)\n    p2: Vector(0, 0)\n    x: 0\n    y: 0\n    w: 0\n    h: 0\n\n    updateArea() {\n        this.x = min(this.p1.x, this.p2.x)\n        this.y = min(this.p1.y, this.p2.y)\n        this.w = abs(this.p1.x - this.p2.x)\n        this.h = abs(this.p1.y - this.p2.y)\n    }\n}\n\nreindexTree = () => {\n    rootNode.reindex((node) => {\n        fullWidth = 0\n        if (node.children.size > 0) {\n            node.children.forEach((childNode) => {\n                fullWidth += childNode.data.get('fullWidth')\n            })\n            fullWidth = fullWidth + (node.children.size - 1) * hGap\n        } else {\n            fullWidth = width\n        }\n        node.data.set('fullWidth', fullWidth)\n    })\n}\n\n\nitems = List()\nrootNode = decodeTree(nodes, ',', ':')\nreindexTree()\n\nconnectors = List()\n\nnodesById = Map()\n\nvisitTree = (node, parent) => {\n    nodesById.set(node.id, node)\n\n    if (!parent) {\n        node.x = 0\n        node.y = 0\n    } else {\n        node.y = node.level * (height + vGap)\n    }\n    items.add(node)\n\n    axis = node.x + width/2\n    childOffset = axis - node.data.get('fullWidth')/2\n    node.children.forEach((childNode) => {\n        childFullWidth = childNode.data.get('fullWidth')\n        childNode.x = childOffset + (childFullWidth - width)/2\n        childOffset = childNode.x + (width + childFullWidth)/2 + hGap\n        visitTree(childNode, node)\n\n        connector = Connector(`connector_${node.id}_${childNode.id}`, node.id, childNode.id)\n        connector.p1 = Vector(node.x + width/2, node.y + height)\n        connector.p2 = Vector(childNode.x + width/2, childNode.y)\n        connector.updateArea()\n        connectors.add(connector)\n    })\n}\n\nvisitTree(rootNode, 0, null)\n\ncreateNewChildFor = (nodeId) => {\n    node = nodesById.get(nodeId)\n    if (node) {\n        TreeNode(uid()).attachTo(node)\n        reindexTree()\n    }\n    nodes = rootNode.encodeTree(',', ':')\n}\n\ncreateNewSiblingFor = (nodeId, idx) => {\n    node = nodesById.get(nodeId)\n    if (node && node.parent) {\n        node.parent.attachChildAtIndex(TreeNode(uid()), idx)\n        reindexTree()\n    }\n    nodes = rootNode.encodeTree(',', ':')\n}\n\non('delete', (itemId, item) => {\n    node = nodesById.get(itemId)\n    if (node && node.parent) {\n        node.parent.children.remove(node.siblingIdx)\n        reindexTree()\n    }\n    nodes = rootNode.encodeTree(',', ':')\n})\n", "controls": [{"$-foreach": {"source": "items", "it": "item"}, "name": {"$-str": "addChild_${item.id}"}, "type": "button", "text": "+", "placement": "TL", "x": {"$-expr": "if (item.level > 0) { item.x + width/2 - 10 } else { item.x + width/4 - 10 }"}, "y": {"$-expr": "item.y + height + 5"}, "width": 20, "height": 20, "selectedItemId": {"$-expr": "item.id"}, "data": {"nodeId": {"$-expr": "item.id"}}, "click": "createNewChildFor(control.data.nodeId)"}, {"$-foreach": {"source": "items", "it": "item"}, "$-if": "item.parent != null", "name": {"$-str": "addSiblingLeft_${item.id}"}, "type": "button", "text": "+", "placement": "TR", "x": {"$-expr": "item.x - 5"}, "y": {"$-expr": "item.y + height/2 - 10"}, "width": 20, "height": 20, "selectedItemId": {"$-expr": "item.id"}, "data": {"nodeId": {"$-expr": "item.id"}, "siblingIdx": {"$-expr": "item.siblingIdx"}}, "click": "createNewSiblingFor(control.data.nodeId, control.data.siblingIdx)"}, {"$-foreach": {"source": "items", "it": "item"}, "$-if": "item.parent != null", "name": {"$-str": "addSiblingRight_${item.id}"}, "type": "button", "text": "+", "placement": "TL", "x": {"$-expr": "item.x + width + 5"}, "y": {"$-expr": "item.y + height/2 - 10"}, "width": 20, "height": 20, "selectedItemId": {"$-expr": "item.id"}, "data": {"nodeId": {"$-expr": "item.id"}, "siblingIdx": {"$-expr": "item.siblingIdx"}}, "click": "createNewSiblingFor(control.data.nodeId, control.data.siblingIdx+1)"}], "item": {"id": {"$-expr": "rootNode.id"}, "name": "Tree chart", "shape": "rect", "args": {"templateIgnoredProps": ["shapeProps.fill", "shapeProps.strokeColor", "shapeProps.strokeSize", "shapeProps.strokePattern"]}, "area": {"x": 0, "y": 0, "w": {"$-expr": "width"}, "h": {"$-expr": "height"}}, "shapeProps": {"cornerRadius": {"$-expr": "cornerRadius"}}, "childItems": [{"$-foreach": {"source": "items", "it": "item"}, "$-if": "item.id.trim() != '' && item.level > 0", "id": {"$-expr": "item.id"}, "area": {"x": {"$-expr": "item.x"}, "y": {"$-expr": "item.y"}, "w": {"$-expr": "width"}, "h": {"$-expr": "height"}}, "textSlots": {}, "name": {"$-str": "Node ${item.id}"}, "shape": "rect", "args": {"templateIgnoredProps": ["shapeProps.fill", "shapeProps.strokeColor", "shapeProps.strokeSize", "shapeProps.strokePattern"]}, "shapeProps": {"cornerRadius": {"$-expr": "cornerRadius"}}}, {"$-foreach": {"source": "connectors", "it": "c"}, "$-if": "c.id.trim() != ''", "id": {"$-expr": "c.id"}, "area": {"x": {"$-expr": "0"}, "y": {"$-expr": "0"}, "w": {"$-expr": "width"}, "h": {"$-expr": "height"}}, "name": {"$-str": "Connector"}, "shape": "connector", "shapeProps": {"sourceItem": {"$-str": "#${c.srcId}"}, "destinationItem": {"$-str": "#${c.dstId}"}, "sourceItemPosition": 0, "destinationItemPosition": 0, "sourcePin": "b", "destinationPin": "t", "destinationCap": {"$-expr": "capType"}, "destinationCapSize": {"$-expr": "capSize"}, "sourceCap": "empty", "smoothing": {"$-expr": "connectorType"}, "points": [{"x": {"$-expr": "c.p1.x"}, "y": {"$-expr": "c.p1.y"}, "nx": 0, "ny": 1, "id": "first"}, {"x": {"$-expr": "c.p2.x"}, "y": {"$-expr": "c.p2.y"}, "nx": 0, "ny": -1, "id": "last"}]}}]}}