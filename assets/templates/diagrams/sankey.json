{"name": "Sankey diagram", "description": "This template converts your diagram code below into an interactive Sankey diagram.\nTo define a connection in your diagram between the two nodes \"A\" and \"B\" type it like this \"A [150] B\".\nEvery connection should be defined in a separate line.\n", "args": {"nodesData": {"type": "string", "value": "a1_1;x=0;y=0;|a1_2|a2", "name": "Nodes encoded", "hidden": true}, "diagramCode": {"type": "string", "value": "Wages [2000] Budget\nOther [120] Budget\nBudget [1000] Housing\nBudget [450] Taxes\n", "name": "Diagram", "textarea": true, "rows": 15}, "colorTheme": {"group": "Theme & Colors", "type": "choice", "value": "default", "options": ["default", "light", "dark", "air-force-blue", "gray", "custom"], "name": "Color theme"}, "conColorType": {"group": "Theme & Colors", "type": "choice", "value": "source", "options": ["source", "destination", "gradient", "custom"], "name": "Connection color type"}, "conColor": {"group": "Theme & Colors", "type": "advanced-color", "value": {"type": "solid", "color": "#aaaaaa"}, "name": "Connection color", "depends": {"conColorType": "custom"}}, "labelColor": {"group": "Theme & Colors", "type": "color", "value": "#222222", "name": "Text color"}, "nodeWidth": {"group": "Nodes", "type": "number", "value": 20, "name": "Node width", "min": 1}, "nodeSpacing": {"group": "Nodes", "type": "number", "value": 40, "name": "Nodes empty space (%)", "min": 0, "max": 90}, "nodeCornerRadius": {"group": "Nodes", "type": "number", "value": 5, "name": "Corner radius", "min": 0}, "nodeStrokeSize": {"group": "Nodes", "type": "number", "value": 1, "name": "Stroke size", "min": 0}, "nodeStrokeColor": {"group": "Nodes", "type": "color", "value": "rgba(255,255,255,1)", "name": "Stroke color"}, "curviness": {"group": "Connections", "type": "number", "value": 80, "name": "Curviness (%)", "min": 0, "max": 100}, "conOpacity": {"group": "Connections", "type": "number", "value": 60, "name": "Connector opacity", "min": 0, "max": 100}, "conHoverStroke": {"group": "Connections", "type": "color", "value": "rgba(30,30,30,1)", "name": "Connection hover stroke"}, "conHoverStrokeSize": {"group": "Connections", "type": "number", "value": 1, "name": "Connection hover stroke size"}, "font": {"group": "Labels & Text", "type": "font", "value": "Arial", "name": "Font"}, "fontSize": {"group": "Labels & Text", "type": "number", "value": 14, "name": "Font size", "min": 1}, "magnify": {"group": "Labels & Text", "type": "number", "value": 0, "name": "Magnify value", "min": -50, "max": 50}, "labelPlacement": {"group": "Labels & Text", "type": "choice", "value": "inside", "options": ["inside", "outside"], "name": "Label placement"}, "conLabel": {"group": "Labels & Text", "type": "boolean", "value": true, "name": "Connection labels enabled", "description": "Displays the value of the connection"}, "showLabelFill": {"group": "Labels & Text", "type": "boolean", "value": true, "name": "Show label fill"}, "labelFill": {"group": "Labels & Text", "type": "advanced-color", "value": {"type": "solid", "color": "#FCE6AC82"}, "name": "Background", "depends": {"showLabelFill": true}}, "labelStroke": {"group": "Labels & Text", "type": "color", "value": "#97654299", "name": "Label stroke", "depends": {"showLabelFill": true}}, "labelStrokeSize": {"group": "Labels & Text", "type": "number", "value": 1, "name": "Label stroke size", "depends": {"showLabelFill": true}}, "labelCornerRadius": {"group": "Labels & Text", "type": "number", "value": 4, "name": "Label corner radius", "min": 0, "depends": {"showLabelFill": true}}, "labelPadding": {"group": "Labels & Text", "type": "number", "value": 5, "name": "Label padding", "depends": {"showLabelFill": true}}, "showNodeValues": {"group": "Values", "type": "boolean", "value": true, "name": "Show node values"}, "valuePrefix": {"group": "Values", "type": "string", "value": "", "name": "Value prefix"}, "valueSuffix": {"group": "Values", "type": "string", "value": "", "name": "Value suffix"}, "numberFormat": {"group": "Values", "type": "choice", "value": "1000000.00", "options": ["1000000.00", "1000000,00", "1,000,000.00", "1.000.000,00", "1 000 000.00", "1 000 000,00"], "name": "Number format"}}, "preview": "/assets/templates/previews/sankey.svg", "defaultArea": {"x": 0, "y": 0, "w": 200, "h": 60}, "import": ["./src/item.sch", "./src/control.sch", "./src/sankey.sch"], "handlers": {"area": "onAreaUpdate(itemId, item, area)", "text": "onTextUpdate(itemId, item, text)", "delete": "onDeleteItem(itemId, item)", "shapeProps": "onShapePropsUpdate(itemId, item, name, value)"}, "controls": [{"$-foreach": {"source": "allConnections", "it": "c"}, "data": {"connectionId": {"$-expr": "c.id"}}, "selectedItemId": {"$-expr": "c.id"}, "name": "connectionValue", "type": "textfield", "text": {"$-str": "${c.value}"}, "placement": {"$-expr": "if (c.srcNode.offset > c.dstNode.offset) { 'TL' } else { 'BL' }"}, "x": {"$-expr": "c.item.x"}, "y": {"$-expr": "if (c.srcNode.offset > c.dstNode.offset) { c.item.y + c.item.h } else { c.item.y }"}, "width": 180, "height": 30, "input": ["onConnectionValueInput(control.data.connectionId, value)"]}, {"$-foreach": {"source": "nodeControls", "it": "control"}, "$-extend": {"$-expr": "toJSON(control)"}}], "item": {"id": "root", "name": "Sankey diagram", "shape": "dummy", "shapeProps": {"fill": {"type": "none"}, "strokeColor": "rgba(200,200,200,1)"}, "locked": false, "area": {"x": 0, "y": 0, "w": {"$-expr": "width"}, "h": {"$-expr": "height"}}, "childItems": [{"$-foreach": {"source": "connectorItems", "it": "it"}, "id": {"$-str": "c-${it.id}"}, "tags": ["sankey-connector"], "name": {"$-expr": "it.name"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "toJSON(it.getArgs())"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "selfOpacity": {"$-expr": "conOpacity"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}, "childItems": [{"$-foreach": {"source": "it.childItems", "it": "label"}, "id": {"$-expr": "label.id"}, "name": {"$-expr": "label.name"}, "shape": "rect", "tags": ["connector-label"], "shapeProps": {"$-expr": "toJSON(label.shapeProps)"}, "args": {"$-expr": "toJSON(label.getArgs())"}, "locked": {"$-expr": "label.locked"}, "textSlots": {"$-expr": "toJSON(label.textSlots)"}, "visible": true, "opacity": 100, "area": {"x": {"$-expr": "label.x"}, "y": {"$-expr": "label.y"}, "w": {"$-expr": "label.w"}, "h": {"$-expr": "label.h"}}, "behavior": {"events": [{"id": "init", "event": "init", "actions": [{"id": "a1", "element": "self", "method": "hide", "args": {"animated": false}}]}]}}], "behavior": {"events": [{"id": "mousein", "event": "mousein", "actions": [{"id": "a1", "element": "self", "method": "set", "args": {"field": "shapeProps.strokeSize", "value": {"$-expr": "conHoverStrokeSize"}, "animated": true, "animationDuration": 0.2, "transition": "ease-in-out", "inBackground": true}}, {"id": "a2", "element": {"$-str": "#cl-${it.id}"}, "method": "show", "args": {"animated": true, "animationDuration": 0.2}}]}, {"id": "mouseout", "event": "mouseout", "actions": [{"id": "a1", "element": "self", "method": "set", "args": {"field": "shapeProps.strokeSize", "value": 0, "animated": true, "animationDuration": 0.2, "transition": "ease-in-out", "inBackground": true}}, {"id": "a2", "element": {"$-str": "#cl-${it.id}"}, "method": "hide", "args": {"animated": true, "animationDuration": 0.2}}]}]}}, {"$-foreach": {"source": "nodeItems", "it": "it"}, "id": {"$-expr": "it.id"}, "tags": ["sankey-node"], "name": {"$-expr": "it.name"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "toJSON(it.getArgs())"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}}, {"$-foreach": {"source": "nodeLabels", "it": "it"}, "id": {"$-expr": "it.id"}, "name": {"$-expr": "it.name"}, "shape": {"$-expr": "it.shape"}, "shapeProps": {"$-expr": "toJSON(it.shapeProps)"}, "args": {"$-expr": "toJSON(it.getArgs())"}, "locked": {"$-expr": "it.locked"}, "textSlots": {"$-expr": "toJSON(it.textSlots)"}, "area": {"x": {"$-expr": "it.x"}, "y": {"$-expr": "it.y"}, "w": {"$-expr": "it.w"}, "h": {"$-expr": "it.h"}}, "childItems": [{"$-foreach": {"source": "it.childItems", "it": "child"}, "id": {"$-expr": "child.id"}, "name": {"$-expr": "child.name"}, "shape": {"$-expr": "child.shape"}, "shapeProps": {"$-expr": "toJSON(child.shapeProps)"}, "args": {"$-expr": "toJSON(child.getArgs())"}, "locked": {"$-expr": "child.locked"}, "textSlots": {"$-expr": "toJSON(child.textSlots)"}, "area": {"x": {"$-expr": "child.x"}, "y": {"$-expr": "child.y"}, "w": {"$-expr": "child.w"}, "h": {"$-expr": "child.h"}}}]}]}, "init": "\nstruct Item {\n    id: uid()\n    name: ''\n    shape: 'rect'\n    x: 0\n    y: 0\n    w: 100\n    h: 50\n    shapeProps: Map()\n    childItems: List()\n    args: Map()\n    locked: true\n    textSlots: Map()\n    description: \"\"\n\n\n    traverse(callback) {\n        this.childItems.forEach((childItem) => {\n            childItem.traverse(callback)\n        })\n        callback(this)\n    }\n\n    getArgs() {\n        toJSON(this.args)\n    }\n\n    setText(slotName, text) {\n        if (!this.textSlots.has(slotName)) {\n            this.textSlots.set(slotName, Map('text', text))\n        } else {\n            this.textSlots.get(slotName).set('text', text)\n        }\n    }\n\n    toJSON() {\n        childItems = this.childItems.map((childItem) => { childItem.toJSON() })\n        result = toJSON(Map(\n            'id', this.id,\n            'childItems', childItems,\n            'name', this.name,\n            'description', this.description,\n            'shape', this.shape,\n            'area', Map('x', this.x, 'y', this.y, 'w', this.w, 'h', this.h, 'r', 0, 'sx', 1, 'sy', 1, 'px', 0.5, 'py', 0.5),\n            'shapeProps', this.shapeProps,\n            'args', this.args,\n            'locked', this.locked,\n            'textSlots', this.textSlots,\n        ))\n\n        result\n    }\n}\n\n\n\nstruct Control {\n    name: \"\"\n    data: Map()\n    click: \"log('control clicked')\"\n    x: 0\n    y: 0\n    width: 20\n    height: 20\n    text: \"+\"\n    placement: \"TL\"\n    selectedItemId: \"\"\n    type: 'button'\n    options: List()\n    optionsProvider: null\n}\n\nlocal gapRatio = nodeSpacing / 100\nlocal labelFontSize = max(1, round(fontSize * (100 - magnify) / 100))\nlocal valueFontSize = max(1, round(fontSize * (100 + magnify) / 100))\n\nlocal nodesById = Map()\n\nlocal colorThemes = Map(\n    'default', List('#F16161', '#F1A261', '#F1EB61', '#71EB57', '#57EBB1', '#57C2EB', '#576BEB', '#A557EB', '#EB57C8', '#EB578E'),\n    'light', List('#FD9999', '#FDCA99', '#F9FD99', '#C2FD99', '#99FDA6', '#99FDE2', '#99EAFD', '#99BEFD', '#AE99FD', '#FD99F6'),\n    'dark', List('#921515', '#924E15', '#899215', '#4E9215', '#15922B', '#15926B', '#157F92', '#153F92', '#491592', '#921575'),\n    'air-force-blue', List('#5d8aa8'),\n    'gray', List('#6B6B64'),\n)\n\nstruct Node {\n    id: uid()\n    name: 'Unnamed'\n    value: 0\n    inValue: 0\n    outValue: 0\n    color: '#FD9999'\n    x: 0\n    y: 0\n    level: 0\n    sortOrder: 0 // Position inside of its level\n    srcNodes: List()\n    dstNodes: List()\n    width: 0\n    height: 0\n    position: 0\n    offset: 0\n    unitSize: 1\n    reservedIn: 0\n    reservedOut: 0\n}\n\nstruct Connection {\n    id: uid()\n    srcId: ''\n    dstId: ''\n    value: 0\n    srcNode: null\n    dstNode: null\n    item: null\n}\n\nstruct CodeLine {\n    text: ''\n    connection: null\n}\n\nstruct Level {\n    idx: 0\n    nodes: List()\n    nodesMap: Map()\n    totalValue: 0\n    height: 0\n}\n\nstruct PathPoint {\n    t: 'B'\n    x: 0\n    y: 0\n    x1: 0\n    y1: 0\n    x2: 0\n    y2: 0\n}\n\n\nfunc encodeNodes(nodes) {\n    local result = ''\n\n    nodes.forEach(n => {\n        if (result != '') {\n            result += '|'\n        }\n        result += `${n.id};x=${n.x};y=${n.y};c=${n.color}`\n    })\n    result\n}\n\nfunc decodeNodesData(text) {\n    local nodesById = Map()\n    splitString(text, '|').forEach(singleNodeText => {\n        local node = Node()\n        local parts = splitString(singleNodeText, ';')\n        for (local i = 0; i < parts.size; i++) {\n            if (i == 0) {\n                node.id = parts.get(0)\n            } else {\n                local varValue = splitString(parts.get(i), '=')\n                if (varValue.size == 2) {\n                    local name = varValue.get(0)\n                    local value = varValue.get(1)\n                    if (name == 'x') {\n                        node.x = value\n                    } else if (name == 'y') {\n                        node.y = value\n                    } else if (name == 'c') {\n                        node.color = value\n                    }\n                }\n            }\n        }\n        nodesById.set(node.id, node)\n    })\n    nodesById\n}\n\n\nfunc parseConnection(line) {\n    local s1 = line.indexOf('[')\n    local s2 = line.indexOf(']')\n\n    if (s1 > 0 && s2 > s1) {\n        local nodeName1 = line.substring(0, s1).trim()\n        local nodeName2 = line.substring(s2+1).trim()\n        local valueText = line.substring(s1+1, s2)\n\n        if (nodeName1 != '' && nodeName2 != '') {\n            local value = parseFloat(valueText)\n            local id = nodeName1 + '[]' + nodeName2\n            Connection(id, nodeName1, nodeName2, value)\n        } else {\n            null\n        }\n    } else {\n        null\n    }\n}\n\nfunc parseConnections(text, nodesData) {\n    local getOrCreateNode = (id) => {\n        local node = nodesById.get(id)\n        if (!node) {\n            node = Node(id, id)\n            nodesById.set(id, node)\n        }\n        local nData = nodesData.get(id)\n        if (nData) {\n            node.x = nData.x\n            node.y = nData.y\n            if (nData.color) {\n                node.color = nData.color\n            }\n        }\n        node\n    }\n\n    local lines = List()\n    splitString(text, '\\n').forEach(rawLine => {\n        local line = rawLine.trim()\n        local c = null\n        if (line != '' && !line.startsWith('//')) {\n            c = parseConnection(line)\n        }\n        if (c) {\n            c.srcNode = getOrCreateNode(c.srcId)\n            c.dstNode = getOrCreateNode(c.dstId)\n            lines.add(CodeLine(rawLine, c))\n        } else {\n            lines.add(CodeLine(rawLine, null))\n        }\n    })\n    lines\n}\n\nfunc extractNodesFromConnections(connections) {\n    local nodeIds = Set()\n    local list = List()\n\n    connections.forEach(c => {\n        if (!nodeIds.has(c.srcNode.id)) {\n            nodeIds.add(c.srcNode.id)\n            list.add(c.srcNode)\n        }\n        if (!nodeIds.has(c.dstNode.id)) {\n            nodeIds.add(c.dstNode.id)\n            list.add(c.dstNode)\n        }\n    })\n\n    list\n}\n\n\n// Performs a recursive tree iteration and updates the levels in nodes\n// maxVisitCount is used in order to prevent from infinite loop in case there is a cyclic dependency\nfunc updateLevels(node, maxVisitCount) {\n    if (maxVisitCount >= 0) {\n        node.dstNodes.forEach(dstNode => {\n            local newLevel = node.level + 1\n            if (dstNode.level < newLevel) {\n                dstNode.level = newLevel\n                updateLevels(dstNode, maxVisitCount - 1)\n            }\n        })\n    }\n}\n\nfunc readjustStarterNodeLevels(nodesMap) {\n    // readjusting node levels for starter nodes\n    nodesMap.forEach(node => {\n        if (node.srcNodes.size == 0 && node.dstNodes.size > 0) {\n            local minDstLevel = node.dstNodes.get(0).level\n            node.dstNodes.forEach(dstNode => {\n                if (minDstLevel > dstNode.level) {\n                    minDstLevel = dstNode.level\n                }\n            })\n            if (minDstLevel - node.level > 1) {\n                node.level = minDstLevel - 1\n            }\n        }\n    })\n}\n\nfunc buildLevels(allNodes, allConnections) {\n    local nodesMap = Map()\n    allNodes.forEach(node => {\n        nodesMap.set(node.id, node)\n    })\n\n    allConnections.forEach(c => {\n        if (c.srcId != c.dstId) {\n            local srcNode = nodesMap.get(c.srcId)\n            if (!srcNode) {\n                srcNode = Node(c.srcId)\n                nodesMap.set(c.srcId, srcNode)\n            }\n            local dstNode = nodesMap.get(c.dstId)\n            if (!dstNode) {\n                dstNode = Node(c.dstId)\n                nodesMap.set(c.dstId, dstNode)\n            }\n\n            local value = abs(c.value)\n            srcNode.outValue += value\n            dstNode.inValue += value\n            srcNode.dstNodes.add(dstNode)\n            dstNode.srcNodes.add(srcNode)\n        }\n    })\n\n    nodesMap.forEach(node => {\n        if (node.srcNodes.size == 0) {\n            node.level = 0\n            updateLevels(node, nodesMap.size)\n        }\n    })\n\n    readjustStarterNodeLevels(nodesMap)\n\n    local levels = Map()\n    local maxLevel = 0\n    nodesMap.forEach(node => {\n        node.value = max(node.inValue, node.outValue)\n        local level = levels.get(node.level)\n        if (level) {\n            level.nodes.add(node)\n        } else {\n            levels.set(node.level, Level(node.level, List(node), nodesMap))\n        }\n        if (maxLevel < node.level) {\n            maxLevel = node.level\n        }\n    })\n\n    local allLevels = List()\n    for (local i = 0; i <= maxLevel; i++) {\n        local level = levels.get(i)\n        if (level) {\n            level.nodes.sort((a, b) => {\n                b.value - a.value\n            })\n            level.nodes.forEach((n, idx) => {\n                n.sortOrder = idx\n            })\n            allLevels.add(level)\n            level.totalValue = 0\n            level.nodes.forEach(node => {\n                level.totalValue += node.value\n            })\n        }\n    }\n\n    allLevels\n}\n\n\nfunc buildNodeItems(levels) {\n    local colorPalette = colorThemes.get(colorTheme)\n    if (!colorPalette) {\n        colorPalette = colorThemes.get('default')\n    }\n\n    local maxLevelValue = 0\n    local maxNodesPerLevel = 0\n    levels.forEach(level => {\n        if (maxLevelValue < level.totalValue) {\n            maxLevelValue = level.totalValue\n        }\n        if (maxNodesPerLevel < level.nodes.size) {\n            maxNodesPerLevel = level.nodes.size\n        }\n    })\n\n    local nodeItems = List()\n\n    if (maxLevelValue > 0 && maxNodesPerLevel > 0) {\n        local unitSize = height * (1 - gapRatio) / maxLevelValue\n        local singleGap = height * gapRatio / maxNodesPerLevel\n\n        levels.forEach(level => {\n            local levelPosition = level.idx * max(1, width - nodeWidth) / (levels.size - 1)\n            local levelSize = level.totalValue * unitSize + singleGap * (level.nodes.size - 1)\n            local levelOffset = height / 2 - levelSize / 2\n\n            local currentY = levelOffset\n            level.nodes.forEach(node => {\n                node.unitSize = unitSize\n                node.height = unitSize * node.value\n                node.width = nodeWidth\n                node.position = levelPosition\n                node.offset = currentY\n                local hashCode = Strings.hashCode(node.name)\n                if (colorTheme != 'custom') {\n                    node.color = colorPalette.get(abs(hashCode) % colorPalette.size)\n                }\n\n                local nodeItem = Item('n-' + node.id, node.name, 'rect')\n                nodeItem.w = node.width\n                nodeItem.h = node.height\n                nodeItem.x = node.position + node.x * width\n                nodeItem.y = node.offset + node.y * height\n                nodeItem.shapeProps.set('strokeSize', nodeStrokeSize)\n                nodeItem.shapeProps.set('strokeColor', nodeStrokeColor)\n                nodeItem.shapeProps.set('cornerRadius', nodeCornerRadius)\n\n                nodeItem.shapeProps.set('fill', Fill.solid(node.color))\n\n                nodeItem.args.set('tplArea', 'movable')\n                nodeItem.args.set('tplConnector', 'off')\n                nodeItem.args.set('tplRotation', 'off')\n                nodeItem.locked = false\n                nodeItems.add(nodeItem)\n\n                currentY += nodeItem.h + singleGap\n            })\n        })\n    }\n    nodeItems\n}\n\nfunc buildConnectorItems(levels, allConnections, allNodes) {\n    local k2 = max(allConnections.size, allNodes.size)\n    local k1 = k2 ^ 2\n    local connectorItems = List()\n    local connectionsBySource = Map()\n    allConnections.forEach(c => {\n        if (c.srcId != c.dstId) {\n            local cs = connectionsBySource.get(c.srcId)\n            if (cs) {\n                cs.add(c)\n            } else {\n                connectionsBySource.set(c.srcId, List(c))\n            }\n        }\n    })\n\n    local cs = List()\n\n    levels.forEach(level => {\n        level.nodes.forEach(node => {\n            local connections = connectionsBySource.get(node.id)\n            if (connections) {\n                connections.sort((a, b) => {\n                    a.dstNode.offset + a.dstNode.y * height - (b.dstNode.offset + b.dstNode.y * height)\n                })\n                connections.forEach(c => {\n                    local dstNode = level.nodesMap.get(c.dstId)\n                    if (dstNode) {\n                        cs.add(c)\n                    }\n                })\n            }\n        })\n    })\n\n    cs.sort((a, b) => {\n        a.srcNode.offset + a.srcNode.y * height - (b.srcNode.offset + b.srcNode.y * height)\n    })\n\n    cs.forEach(c => {\n        connectorItems.add(buildSingleConnectorItem(c, c.srcNode, c.dstNode))\n    })\n\n    connectorItems\n}\n\n\nfunc buildSingleConnectorItem(connector, srcNode, dstNode) {\n    local item = Item(connector.id, `${srcNode.id} -> ${dstNode.id}`, 'path')\n    local connectorSize = srcNode.unitSize * connector.value\n\n    local xs = srcNode.position + srcNode.x * width + srcNode.width\n    local ys1 = srcNode.offset + srcNode.y * height + srcNode.reservedOut\n    local ys2 = ys1 + connectorSize\n    srcNode.reservedOut += connectorSize\n\n    local xd = dstNode.position + dstNode.x * width\n    local yd1 = dstNode.offset + dstNode.y * height + dstNode.reservedIn\n    local yd2 = yd1 + connectorSize\n    dstNode.reservedIn += connectorSize\n\n    local minX = min(xs, xd)\n    local maxX = max(xs, xd)\n    local minY = min(ys1, ys2, yd1, yd2)\n    local maxY = max(ys1, ys2, yd1, yd2)\n\n    local dx = max(0.001, maxX - minX)\n    local dy = max(0.001, maxY - minY)\n\n    local t = curviness / 100\n\n    local points = List(\n        PathPoint('B', xs, ys1, 0, t * (ys2 - ys1) / 2, t * (xd - xs) / 2, 0),\n        PathPoint('B', xd, yd1, t * (xs - xd) / 2, 0, 0, t * (yd2 - yd1) / 2),\n        PathPoint('B', xd, yd2, 0, t * (yd1 - yd2) / 2, t * (xs - xd) / 2, 0),\n        PathPoint('B', xs, ys2, t * (xd - xs) / 2, 0, 0, t * (ys1 - ys2) / 2),\n    ).map(p => {\n        PathPoint('B',\n            100 * (p.x - minX) / dx, 100 * (p.y - minY) / dy,\n            100 * p.x1 / dx, 100 * p.y1 / dy,\n            100 * p.x2 / dx, 100 * p.y2 / dy\n        )\n    })\n\n    item.x = minX\n    item.y = minY\n    item.w = dx\n    item.h = dy\n\n    if (conColorType == 'gradient') {\n        item.shapeProps.set('fill', Fill.linearGradient(90, 0, srcNode.color, 100, dstNode.color))\n    } else if (conColorType == 'source') {\n        item.shapeProps.set('fill', Fill.solid(srcNode.color))\n    } else if (conColorType == 'destination') {\n        item.shapeProps.set('fill', Fill.solid(dstNode.color))\n    } else {\n        item.shapeProps.set('fill', conColor)\n    }\n    item.shapeProps.set('strokeSize', 0)\n    item.shapeProps.set('strokeColor', conHoverStroke)\n    item.shapeProps.set('paths', List(Map(\n        'id', 'p-' + connector.id,\n        'closed', true,\n        'pos', 'relative',\n        'points', points\n    )))\n\n    if (conLabel) {\n        item.childItems.add(buildConnectorLabel(connector, item.w, item.h))\n    }\n    connector.item = item\n    item\n}\n\nfunc buildConnectorLabel(c, connectorWidth, connectorHeight) {\n    local valueText = formatValue(c.value)\n    local valueTextSize = calculateTextSize(valueText, font, fontSize)\n    local valueLabel = buildLabel('cl-' + c.id, valueText, font, fontSize, 'center', 'middle')\n    valueLabel.w = valueTextSize.w + 4 + 2 * labelPadding\n    valueLabel.h = valueTextSize.h * 1.8 + 2 * labelPadding\n    valueLabel.x = connectorWidth/2 - valueLabel.w/2 - labelPadding\n    valueLabel.y = connectorHeight/2 - valueLabel.h/2 - labelPadding\n    valueLabel.name = 'connector-label-' + c.id\n    valueLabel.shapeProps.set('strokeColor', labelStroke)\n    valueLabel.args.set('tplText', Map('body', '' + c.value))\n    if (showLabelFill) {\n        valueLabel.shapeProps.set('fill', labelFill)\n        valueLabel.shapeProps.set('strokeColor', labelStroke)\n        valueLabel.shapeProps.set('strokeSize', labelStrokeSize)\n        valueLabel.shapeProps.set('cornerRadius', labelCornerRadius)\n    } else {\n        valueLabel.shapeProps.set('fill', Fill.none())\n        valueLabel.shapeProps.set('strokeSize', 0)\n        valueLabel.shapeProps.set('cornerRadius', 0)\n    }\n    valueLabel\n}\n\nfunc buildLabel(id, text, font, fontSize, halign, valign) {\n    local item = Item(id, text, 'none')\n    item.args.set('templateForceText', true)\n    item.textSlots.set('body', Map(\n        'text', text,\n        'font', font,\n        'color', labelColor,\n        'fontSize', fontSize,\n        'halign', halign,\n        'valign', valign,\n        'paddingLeft', 0,\n        'paddingRight', 0,\n        'paddingTop', 0,\n        'paddingBottom', 0,\n        'whiteSpace', 'nowrap'\n    ))\n    item\n}\n\nlocal valueFormaters = Map(\n    '1000000.00', (value) => {\n        numberToLocaleString(value, 'en-US').replaceAll(',', '')\n    },\n    '1000000,00', (value) => {\n        numberToLocaleString(value, 'de-DE').replaceAll('.', '')\n    },\n    '1,000,000.00', (value) => {\n        numberToLocaleString(value, 'en-US')\n    },\n    '1.000.000,00', (value) => {\n        numberToLocaleString(value, 'de-DE')\n    },\n    '1 000 000.00', (value) => {\n        numberToLocaleString(value, 'fi-FI').replaceAll(',', '.')\n    },\n    '1 000 000,00', (value) => {\n        numberToLocaleString(value, 'fi-FI')\n    },\n)\n\nfunc formatValue(value) {\n    local valueText = value\n    if (valueFormaters.has(numberFormat)) {\n        valueText = valueFormaters.get(numberFormat)(value)\n    }\n    valuePrefix + valueText + valueSuffix\n}\n\nfunc buildNodeLabels(nodes) {\n    local labelItems = List()\n    nodes.forEach(node => {\n        local lines = splitString(node.name, '\\\\n')\n        local textWidth = 0\n        local textHeight = 0\n        local nodeText = ''\n        lines.forEach(line => {\n            local textSize = calculateTextSize(line, font, labelFontSize)\n            textWidth = max(textWidth, textSize.w)\n            textHeight += textSize.h\n            nodeText += `<p>${line}</p>`\n        })\n\n\n        local valueText = formatValue(node.value)\n        local valueTextSize = calculateTextSize(valueText, font, valueFontSize)\n        local totalHeight = if (showNodeValues) { (textHeight + valueTextSize.h)*1.8 + 8 } else { textHeight*1.8 + 8 }\n        local isLeft = true\n        if (labelPlacement == 'outside') {\n            isLeft = ((node.level + 1) / max(1, levels.size) <= 0.5)\n        } else {\n            isLeft = (node.dstNodes.size == 0)\n        }\n\n        local halign = 'right'\n        if (!isLeft) {\n            halign = 'left'\n        }\n\n        local label = buildLabel('ln-' + node.id, nodeText, font, labelFontSize, halign, 'middle')\n        label.w = textWidth + 4\n        label.h = textHeight * 1.8\n\n        local valueLabel = null\n        if (showNodeValues) {\n            valueLabel = buildLabel('lv-' + node.id, valueText, font, valueFontSize, halign, 'middle')\n            valueLabel.w = valueTextSize.w + 4\n            valueLabel.h = valueTextSize.h * 1.8\n        }\n\n        if (node.srcNodes.size + node.dstNodes.size == 1) {\n            valueLabel.args.set('tplText', Map('body', '' + node.value))\n        } else {\n            valueLabel.args.set('tplText', Map('body', '<p>Cannot edit value</p><p>Too many connections</p>'))\n        }\n\n        if (showLabelFill) {\n            local rect = Item('lc-'+node.id, 'Label ' + node.id, 'rect')\n            if (valueLabel) {\n                rect.w = max(label.w, valueLabel.w) + 2 * labelPadding\n                rect.h = label.h + valueLabel.h + 2 * labelPadding\n            } else {\n                rect.w = label.w + 2 * labelPadding\n                rect.h = label.h + 2 * labelPadding\n            }\n            if (isLeft) {\n                rect.x = node.position + node.x * width - rect.w - labelPadding\n            } else {\n                rect.x = node.position + node.width + labelPadding + node.x * width\n            }\n            rect.shapeProps.set('fill', labelFill)\n            rect.shapeProps.set('strokeColor', labelStroke)\n            rect.shapeProps.set('strokeSize', labelStrokeSize)\n            rect.shapeProps.set('cornerRadius', labelCornerRadius)\n            rect.y = node.offset + node.y * height + node.height / 2  - totalHeight / 2\n            label.x = labelPadding\n            label.y = labelPadding\n            rect.childItems.add(label)\n\n            if (valueLabel) {\n                valueLabel.x = labelPadding\n                valueLabel.y = label.y + label.h\n                rect.childItems.add(valueLabel)\n            }\n            labelItems.add(rect)\n        } else {\n            if (isLeft) {\n                label.x = node.position - label.w - labelPadding\n                if (valueLabel) {\n                    valueLabel.x = node.position - valueLabel.w - labelPadding\n                }\n            } else {\n                label.x = node.position + node.width + labelPadding\n                if (valueLabel) {\n                    valueLabel.x = node.position + node.width + labelPadding\n                }\n            }\n            label.x += node.x * width\n            label.y = node.offset + node.y * height + node.height / 2  - totalHeight / 2\n            labelItems.add(label)\n\n            if (valueLabel) {\n                valueLabel.x += node.x * width\n                valueLabel.y = label.y + label.h\n                labelItems.add(valueLabel)\n            }\n        }\n    })\n    labelItems\n}\n\n\n\nfunc onAreaUpdate(itemId, item, area) {\n    local node = null\n    if (itemId.startsWith('n-')) {\n        node = nodesById.get(itemId.substring(2))\n    }\n    if (node) {\n        node.x = (area.x - node.position) / max(1, width)\n        node.y = (area.y - node.offset) / max(1, height)\n\n        if (abs(node.x*width) < 7) {\n            node.x = 0\n        }\n\n        nodesData = encodeNodes(nodesById)\n    }\n}\n\n\nfunc onConnectionValueInput(connectionId, value) {\n    allConnections.forEach(c => {\n        if (c.id == connectionId) {\n            c.value = value\n        }\n    })\n    diagramCode = encodeDiagram()\n}\n\n\nfunc encodeDiagram() {\n    local code = ''\n    codeLines.forEach((line, idx) => {\n        if (idx > 0) {\n            code += '\\n'\n        }\n        if (line.connection) {\n            code += line.connection.srcId + ' [' + line.connection.value + '] ' + line.connection.dstId\n        } else {\n            code += line.text\n        }\n    })\n\n    code\n}\n\n\nfunc onTextUpdate(itemId, item, text) {\n    if (itemId.startsWith('ln-')) {\n        text = stripHTML(text.replaceAll('</p>', '</p>\\n')).trim().replaceAll('\\n', '\\\\n')\n        local oldNodeId = itemId.substring(3)\n        local newNodeId = text\n\n        local foundClashingId = false\n\n        for (local i = 0; i < allConnections.size && !foundClashingId; i++) {\n            local c = allConnections.get(i)\n            if (c.srcId == newNodeId && c.dstId == newNodeId) {\n                foundClashingId = true\n            }\n        }\n\n        if (!foundClashingId) {\n            allConnections.forEach(c => {\n                if (c.srcId == oldNodeId) {\n                    c.srcId = newNodeId\n                    c.srcNode.id = newNodeId\n                }\n                if (c.dstId == oldNodeId) {\n                    c.dstId = newNodeId\n                    c.dstNode.id = newNodeId\n                }\n            })\n        }\n\n        diagramCode = encodeDiagram()\n    } else if (itemId.startsWith('cl-')) {\n        text = stripHTML(text).replaceAll('\\n', '').trim()\n        local value = parseFloat(text)\n        local connectionId = itemId.substring(3)\n        local line = codeLines.find(line => { line.connection && line.connection.id == connectionId})\n        if (line) {\n            line.connection.value = value\n            diagramCode = encodeDiagram()\n        }\n    } else if (itemId.startsWith('lv-')) {\n        local nodeId = itemId.substring(3)\n        local changes = 0\n        text = stripHTML(text).replaceAll('\\n', '').trim()\n        codeLines.forEach(line => {\n            if (line.connection && (line.connection.srcId == nodeId || line.connection.dstId == nodeId)) {\n                changes += 1\n                line.connection.value = parseFloat(text)\n            }\n        })\n\n        if (changes == 1) {\n            diagramCode = encodeDiagram()\n        }\n    }\n}\n\n\nfunc onDeleteItem(itemId, item) {\n    local nodeId = null\n    local connectionId = null\n\n    if (itemId.startsWith('n-')) {\n        nodeId = itemId.substring(2)\n    } else if (itemId.startsWith('c-')) {\n        connectionId = itemId.substring(2)\n    }\n\n    if (nodeId) {\n        local node = allNodes.find(node => {node.id == nodeId})\n        if (node && node.level == levels.size - 1) {\n            if (levels.size > 2 && levels.get(node.level).nodes.size == 1) {\n                width -= max(1, width - nodeWidth) / max(1, (levels.size - 1))\n            }\n        }\n    }\n\n    if (connectionId || nodeId) {\n        for (local i = codeLines.size - 1; i >= 0; i--) {\n            local line = codeLines.get(i)\n            if (line.connection) {\n                if (connectionId && line.connection.id == connectionId) {\n                    codeLines.remove(i)\n                } else if (nodeId && (line.connection.srcId == nodeId || line.connection.dstId == nodeId)) {\n                    codeLines.remove(i)\n                }\n            }\n        }\n        if (codeLines.filter(line => {line.connection}).size > 0) {\n            diagramCode = encodeDiagram()\n        }\n    }\n}\n\n\nfunc provideOptionsForDstNode(nodeId) {\n    local options = List('-- Create new node --')\n\n    local node = allNodes.find(n => {n.id == nodeId})\n    if (node) {\n        allNodes.forEach(anotherNode => {\n            if (anotherNode.level > node.level) {\n                options.add(anotherNode.id)\n            }\n        })\n    }\n    options\n}\n\nfunc provideOptionsForSrcNode(nodeId) {\n    local options = List('-- Create new node --')\n\n    local node = allNodes.find(n => {n.id == nodeId})\n    if (node) {\n        allNodes.forEach(anotherNode => {\n            if (anotherNode.level < node.level) {\n                options.add(anotherNode.id)\n            }\n        })\n    }\n    options\n}\n\nfunc generateNodeControls(nodes) {\n    local controls = List()\n    nodes.forEach(node => {\n        if (node.level == levels.size - 1) {\n            controls.add(Control(\n                \"+\",\n                Map(\n                    'nodeId', node.id\n                ),\n                \"addDstNodeForNode(control.data.nodeId)\",\n                node.position + node.x * width + node.width + 20,\n                node.offset + node.y * height + node.height / 2 - 10,\n                20, 20,\n                '+',\n                'TL',\n                'n-' + node.id,\n                'button'\n            ))\n        } else {\n            local control = Control(\n                \"+\",\n                Map(\n                    'nodeId', node.id\n                ),\n                \"addDstConnection(control.data.nodeId, option)\",\n                node.position + node.x * width + node.width + 20,\n                node.offset + node.y * height + node.height / 2 - 10,\n                20, 20,\n                '+',\n                'TL',\n                'n-' + node.id,\n                'choice'\n            )\n\n            control.optionsProvider = `provideOptionsForDstNode(control.data.nodeId)`\n            controls.add(control)\n        }\n\n        if (node.level > 0) {\n            local control = Control(\n                \"+\",\n                Map(\n                    'nodeId', node.id\n                ),\n                \"addSrcConnection(control.data.nodeId, option)\",\n                node.position + node.x * width - 20,\n                node.offset + node.y * height + node.height / 2 - 10,\n                20, 20,\n                '+',\n                'TR',\n                'n-' + node.id,\n                'choice'\n            )\n\n            control.optionsProvider = `provideOptionsForSrcNode(control.data.nodeId)`\n            controls.add(control)\n        }\n    })\n    controls\n}\n\nfunc addDstConnection(nodeId, option) {\n    if (option == '-- Create new node --') {\n        addDstNodeForNode(nodeId)\n    } else {\n        local srcNode = allNodes.find(node => {node.id == nodeId})\n        local dstNode = allNodes.find(node => {node.id == option})\n        if (srcNode && dstNode) {\n            local value = srcNode.value\n            if (srcNode.value - srcNode.outValue > 0) {\n                value = srcNode.value - srcNode.outValue\n            }\n            codeLines.add(CodeLine(`${srcNode.id} [${value}] ${dstNode.id}`, null))\n            diagramCode = encodeDiagram()\n        }\n    }\n}\n\nfunc addSrcConnection(nodeId, option) {\n    if (option == '-- Create new node --') {\n        addSrcNodeForNode(nodeId)\n    } else {\n        local srcNode = allNodes.find(node => {node.id == option})\n        local dstNode = allNodes.find(node => {node.id == nodeId})\n        if (srcNode && dstNode) {\n            local value = srcNode.value\n            if (srcNode.value - srcNode.outValue > 0) {\n                value = srcNode.value - srcNode.outValue\n            }\n            codeLines.add(CodeLine(`${srcNode.id} [${value}] ${dstNode.id}`, null))\n            diagramCode = encodeDiagram()\n        }\n    }\n}\n\n\n\nfunc addDstNodeForNode(nodeId) {\n    addNewNodeForNode(nodeId, true)\n}\n\nfunc addSrcNodeForNode(nodeId) {\n    addNewNodeForNode(nodeId, false)\n}\n\nfunc addNewNodeForNode(nodeId, isDst) {\n    local allNodeIds = Set()\n    local selectedNode = null\n\n    allNodes.forEach(node => {\n        allNodeIds.add(node.id)\n        if (node.id == nodeId) {\n            selectedNode = node\n        }\n    })\n    if (selectedNode) {\n        local idx = 2\n        local foundUniqueId = false\n        local newId = null\n        while(!foundUniqueId && idx < 1000) {\n            newId = selectedNode.id + ' ' + idx\n            if (!allNodeIds.has(newId)) {\n                foundUniqueId = true\n            }\n            idx += 1\n        }\n        if (foundUniqueId) {\n            if (isDst) {\n                codeLines.add(CodeLine(`${selectedNode.id} [${selectedNode.value}] ${newId}`, null))\n            } else {\n                codeLines.add(CodeLine(`${newId} [${selectedNode.value}] ${selectedNode.id}`, null))\n            }\n            diagramCode = encodeDiagram()\n            if (selectedNode.level == levels.size - 1) {\n                width += max(1, width - nodeWidth) / max(1, (levels.size - 1))\n            }\n        }\n    }\n}\n\nfunc onShapePropsUpdate(itemId, item, name, value) {\n    if (itemId.startsWith('n-') && name == 'fill' && value.type == 'solid') {\n        local nodeId = itemId.substring(2)\n        local node = allNodes.find(n => { n.id == nodeId })\n        if (node) {\n            node.color = value.color\n            nodesData = encodeNodes(nodesById)\n        }\n    }\n}\n\n\nlocal nodesDataById = decodeNodesData(nodesData)\n\nlocal codeLines = parseConnections(diagramCode, nodesDataById)\nlocal allConnections = codeLines.filter(cl => { cl.connection != null }).map(cl => { cl.connection })\nlocal allNodes = extractNodesFromConnections(allConnections)\n\nlocal levels = buildLevels(allNodes, allConnections)\n\nlocal nodeItems = buildNodeItems(levels)\nlocal connectorItems = buildConnectorItems(levels, allConnections, allNodes)\nlocal nodeLabels = buildNodeLabels(allNodes)\n\nlocal nodeControls = generateNodeControls(allNodes)\n\n"}